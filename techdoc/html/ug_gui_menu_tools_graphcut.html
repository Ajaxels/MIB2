<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Microscopy Image Browser Graphcut segmentation</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-15">
<meta name="DC.source" content="ug_gui_menu_tools_graphcut.m">
<style>
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,my-a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a,my-a { color:#005fce; text-decoration:none; }
my-a:hover { cursor: pointer; }
a:hover,my-a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:160%; padding: 20px; }

pre { font-size:12px; }
code { font-size: 1.15em; }
pre { margin:0px 0px 15px; overflow-x:auto; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 15px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }




.dropdown { font-family: monospace; border: 1px solid #aaa; border-radius: 0.2em; background-color: #fff; background-color: #e0f5ff; background-color: #e8f5e8; padding: 0.1em 0.4em; font-family: inherit; font-size: 1em; }
.kbd { font-family: monospace; border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.2em 0.2em #ddd; -webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; box-shadow: 0.1em 0.2em 0.2em #ddd; background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient([[:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); padding: 0.1em 0.4em; font-family: inherit; font-size: 1em; }
.h3 { color: #E65100; font-size: 12px; font-weight: bold; }
.code { font-family: monospace; font-size: 10pt; background: #eee; padding: 1pt 3pt; }

#tooltiptext {
  visibility: hidden;
  padding: 5px 10px;
  font-size: 75%;
  line-height:110%;
  text-align: center;
  background-color: black;
  color: #ddd;
  border-radius: 6px;
  position: fixed;
  bottom: 11px;
  right: 62px;
  z-index: 2;
}
#tooltiptext::after {
  content: " ";
  position: absolute;
  top: 50%;
  left: 100%;
  margin-top: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent transparent black;
}
.tooltip:hover #tooltiptext {
  visibility: visible;
}
#return-link {
    position: fixed;
    bottom: 10px;
    right: 10px;
    overflow: visible;
    font-size:120%;
    background: rgba(0, 0, 0, 0.75);
    border-style: solid;
    border-width: 3pt;
    border-color: #202020;
    border-radius: 4px;
    cursor: pointer;
    }
#return-link > p { padding:3px; margin:0; color:#C0C0C0;}
.MATLAB-Help {
width: 100%;
margin-bottom: 12px;
border: 1px solid #ccc;
border-right: none;
border-bottom: none;
font-size: 96%;
line-height: 1.4;
table-layout: fixed;
overflow:hidden;}

.MATLAB-Help > thead > tr > th {
padding: 6px 5px;
border: none;
border-right: 1px solid #ccc;
border-bottom: 1px solid #ccc;
background: #F2F2F2;
color: #000;
font-weight: bold;
text-align: left;
vertical-align: middle;}

.MATLAB-Help td{padding: 5px 5px;
border: none;
border-right: 1px solid #ccc;
border-bottom: 1px solid #ccc;
vertical-align: middle;}

.language-matlab { line-height:135% }

.collapse-link {float:right; line-height:200%; padding-left:10px; margin:0}


details > summary,
.details-div {
  padding: 8px 20px;
  border-style: solid;
  border-width: 1.2pt;
  border-color: #E0E0E0;
}
details > summary {
  border-radius:6px 6px 0 0;
  background-color: #F2F2F2;
  cursor: pointer;
}
.details-div {
  border-top-style: none;
  border-radius: 0 0 6px 6px;
}
.image-fit-svg,
.image-fit {
    max-width:  95%;
    max-height: 100%;
    margin:     auto;
}
.image-fit-svg{ padding:0px; max-width:500px; }
details > img.image-fit-svg{ padding: 0px 0px 10px; }
@media (max-width: 580px) {
  .image-fit-svg { max-width: 95%; }
}
.pretty-link  { color:#001188 !important; }
</style>
<style id="dark-theme">
    h2, h3       { color: #B0B0B0; }
    html body    { background-color: #101010; color: #B0B0B0; }
    .pretty-link { color: #C46313 !important; }
    a, a:visited, my-a  { color: #C46313 }
    a:hover, my-a:hover { color: orange; }
    details > summary,
    .details-div      { border-color:     #505050; }
    details > summary { background-color: #202020; }
    pre.codeinput     { border-width: 1.2pt; border-color:#001B33; background:#001129; color:#F0F0F0; }
    pre.codeoutput    { color:#A5A5A5; }
    span.keyword      { color:#FF9D00; }
    span.comment      { color:#808080; }
    span.string       { color:#3AD900; }
    span.untermstring { color:#FFEE80; }
    span.syscmd       { color:#CCCCCC; }
    .MATLAB-Help, .MATLAB-Help > thead > tr > th, .MATLAB-Help td { border-color:#505050; }
    .MATLAB-Help > thead > tr > th { background: #202020; color: #B0B0B0; }
    .summary-sub-heading { color:#909090; }
    .show-if-light    { display:none }
</style>
<style id="hide-dark">
     .show-if-dark { display:none }
</style>

<style id="anchor-offsets">
    h2::before, a[id]::before{
    content: "";
    display: block;
    height: 100px;
    margin: -100px 0 0;
    visibility: hidden;
    width:10%;
    z-index: -1;
}
</style>

<script>
          var returnElem = null;
          var skipCheck  = false;

          function hide_back_link()
          {
              returnButton.style.display = "none";
              try{
                 window.removeEventListener("scroll", update_back_position, true);
                 window.removeEventListener("resize", update_back_position, true);
                 parent.window.removeEventListener("scroll", update_back_position, true);
                 parent.window.removeEventListener("resize", update_back_position, true);}
              catch(e){}
          }

          function get_offset(element)
          {
              if (!element.getClientRects().length){ return { top: 0, left: 0 }; }
              var rect = element.getBoundingClientRect();
              var win  = element.ownerDocument.defaultView;
              return ( {top:  rect.top  + win.pageYOffset,
                        left: rect.left + win.pageXOffset} );
          }

          function jump_to()
          {
              var clickedElem = event.target;
              var clickedID   = clickedElem.closest("span");
              if (clickedID){
                clickedID = clickedID.getAttribute("id");
                if (clickedID.localeCompare("jump-close")===0) { return };}
              clickedID = clickedElem.closest("div").getAttribute("id");
              if (clickedID && clickedID.localeCompare("return-link")===0)
              {
                  if (returnElem)
                  {
                      event.preventDefault();
                      hide_back_link();
                      returnElem.scrollIntoView();
                      if (contentDiv.getAttribute("data-isHelpBrowser")){
                         contentDiv.scrollTop = contentDiv.scrollTop-100; }
                      if (contentDiv.getAttribute("data-isMATLABCentral")){
                         parent.window.scrollBy(0,-100)}
                      returnElem = null;
                  }
              }
              else
              {
                  var href = clickedElem.closest("my-a").getAttribute("href");
                  if ( href && href[0] == "#" )
                  {
                     var target = document.getElementById(href.substring(1));
                     var enclosingBox = target;
                     while ( enclosingBox )
                     {
                        prevBox      = enclosingBox;
                        enclosingBox = enclosingBox.closest("details");
                        if ( enclosingBox===prevBox ){
                           enclosingBox = enclosingBox.parentElement
                           if ( enclosingBox ) { enclosingBox = enclosingBox.closest("details"); }  }
                        if (enclosingBox && !enclosingBox.open) { open_details(enclosingBox.id) }
                     }
                     if (target){
                        event.preventDefault();
                        target.scrollIntoView(); }
                     var nextElem = target.nextElementSibling;
                     var nextNode = target.nextSibling;
                     while ( nextNode && nextNode.nodeType==Node.TEXT_NODE && nextNode.data.trim().length == 0 ){
                        nextNode = nextNode.nextSibling;}
                     if ( nextElem && nextElem===nextNode && nextElem.localName.localeCompare("details")===0 && !nextElem.open){
                        open_details(nextElem.id);}
                  }
                  else { return }
                  if (!contentDiv.getAttribute("data-isHelpBrowser"))
                  {
                      update_back_position();
                      returnButton.style.display = "block";
                      var linkTop   = clickedElem.offsetTop;
                      var targetTop = target.offsetTop;
                      if (targetTop>linkTop){
                          document.getElementById("down").style.display = "none";
                          document.getElementById("up").style.display   = "inline"; }
                      else{
                          document.getElementById("up").style.display   = "none";
                          document.getElementById("down").style.display = "inline"; }
                      returnElem = clickedElem;
                  }
              }
          }

          function open_details(detailsID)
          {
              var details  = document.getElementById(detailsID);
              skipCheck    = true;
              state_check(details.id);
              details.open = true;
          }

          function update_back_position()
          {
              try
              {
                  window.addEventListener("scroll", update_back_position, true);
                  window.addEventListener("resize", update_back_position, true);
                  var scrollPos;
                  if (in_iFrame())
                  {
                      parent.window.addEventListener("scroll", update_back_position, true);
                      parent.window.addEventListener("resize", update_back_position, true);
                      var iFrame         = window.frameElement;
                      var frameOffset    = get_offset(iFrame);
                      var documentBottom = parent.window.innerHeight  + parent.window.scrollY;
                      var extHeight      = Math.round(frameOffset.top + iFrame.getBoundingClientRect().height - documentBottom);
                      if (extHeight<0) { extHeight = 0; }
                      returnButton.style.bottom = (10+extHeight) + "px";
                      document.getElementById("tooltiptext").style.bottom = (11+extHeight) + "px";
                      scrollPos = contentDiv.scrollTop - 25 + iFrame.getBoundingClientRect().height - extHeight;
                  }
                  else{
                      scrollPos = window.scrollY + window.innerHeight - 25;}
                  if (returnElem.offsetTop>scrollPos){
                      document.getElementById("down").style.display = "inline";
                      document.getElementById("up").style.display   = "none";   }
                  else{
                      document.getElementById("down").style.display = "none";
                      document.getElementById("up").style.display   = "inline"; }
              }
              catch(e){}
          }
          function set_theme(themePref)
          {
            var themeSwitch     = document.getElementById("ToggleTheme");
            var themeSwitchText = "switch to";
            var switchToText    = null;
            if (!themePref){ themePref = get_theme_pref(); }
            if (themePref.localeCompare("light")===0){
                document.getElementById("dark-theme").sheet.disabled = true;
                document.getElementById("hide-dark").sheet.disabled  = false;
                switchToText = " dark theme";}
            else{
                document.getElementById("dark-theme").sheet.disabled = false;
                document.getElementById("hide-dark").sheet.disabled  = true;
                switchToText = " light theme";}
            themeSwitch.innerHTML = themeSwitchText + switchToText;
            set_theme_pref(themePref);
          }

          function toggle_theme()
          {
            if (document.getElementById("dark-theme").sheet.disabled) { set_theme("dark");  }
            else                                                      { set_theme("light"); }
          }

          function set_theme_pref(themePref)
          {
              var d = new Date();
              d.setTime(d.getTime() + (2*365*24*60*60*1000));
              var expires = "expires="+ d.toUTCString();
              document.cookie = "themepref=" + themePref + ";" + expires + "path=/";
              localStorage.setItem("PRETTY_THEME", themePref);
          }

          function get_theme_pref() {
              var name = "themepref=";
              var decodedCookie = decodeURIComponent(document.cookie);
              var ca = decodedCookie.split(';');
              for(var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                  c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                  return c.substring(name.length, c.length);
                }
              }
              var docTheme = localStorage.getItem("PRETTY_THEME");
              if (docTheme) { return docTheme }
              else          { return "light"  }
          }

          function toggle_details(section)
          {
            var link;
            var subSection;
            var details;
            var linkText;
            var i;
            var openState  = true;
            var border     = "6px 6px 0 0;"
            if (section===0)
            {
              link = document.getElementById("Toggle"+section.toString());
              if (link.innerHTML.localeCompare("collapse all on page")===0){
                  openState = false;
                  border    = "6px;"
                  linkText  = "expand all";}
              else{
                  linkText   = "collapse all";}
              link.innerHTML = linkText + " on page";
              for (i = 0; i < allDetails.length; i++){
                 allDetails[i].open = openState;
                 allDetails[i].children[0].setAttribute( 'style', "border-radius:"+border );
                 link = document.getElementById("Toggle"+allDetails[i].id.split(".", 1));
                 if (allDetails[i].id.charAt(0).localeCompare("0") && link){link.innerHTML = linkText;}}
            }
            else
            {
               link = document.getElementById("Toggle"+section.toString());
               subSection = 1;
               if (link.innerHTML.localeCompare("collapse all")===0){
                  openState      = false;
                  border         = "6px;"
                  link.innerHTML = "expand all";}
               else{
                  link.innerHTML = "collapse all";}
               details = document.getElementById(section.toString()+"."+subSection.toString());
               while (details){
                    details.open = openState;
                    details.children[0].setAttribute( 'style', "border-radius:"+border );
                    subSection++;
                    details = document.getElementById(section.toString()+"."+subSection.toString());}
               var allCollapsed = true;
               var allExpanded  = true;
               for (i = 0; i < allDetails.length; i++){
                   check_if_open(allDetails[i]);}
               link = document.getElementById("Toggle0");
               if (allExpanded) {link.innerHTML = "collapse all on page";}
               if (allCollapsed){link.innerHTML = "expand all on page";}
            }
            function check_if_open(details)
            {
                if (details.open){allCollapsed = false;}
                else             {allExpanded  = false;}
            }
          }

          function state_check(detailsID)
          {
              // first deal with just the section
              if (event.detail){document.activeElement.blur();}
              var clickedElem   = event.target;
              if (!skipCheck && clickedElem.localName.localeCompare("summary"))
              { 
                if (!(clickedElem.closest("summary"))) { return };
              };
              var details       = document.getElementById(detailsID);
              if ( !skipCheck ) {
                  var parentID  = clickedElem.closest("details").id;
                  if (details.id.localeCompare(parentID)) { return };}
              skipCheck         = false;
              var clickedStatus = details.open;
              var section       = detailsID.split(".", 1);
              var subSection    = 1;
              var allCollapsed  = true;
              var allExpanded   = true;
              var link          = document.getElementById("Toggle"+section);
              if (clickedStatus) { details.children[0].setAttribute( 'style', "border-radius:6px;" ); }
              else               { details.children[0].setAttribute( 'style', "border-radius:6px 6px 0 0;" ); }
              if (link)
              {
                  details = document.getElementById(section+"."+subSection.toString());
                  while (details){
                    check_if_open(details);
                    subSection++;
                    details = document.getElementById(section+"."+subSection.toString());}
                  if (allExpanded) {link.innerHTML = "collapse all";}
                  if (allCollapsed){link.innerHTML = "expand all";}
              }
              // then the whole page
              allCollapsed   = true;
              allExpanded    = true;
              for (var i = 0; i < allDetails.length; i++){
                  check_if_open(allDetails[i]);}
              link = document.getElementById("Toggle0");
              if (allExpanded) {link.innerHTML = "collapse all on page";}
              if (allCollapsed){link.innerHTML = "expand all on page";}

              function check_if_open(details)
              {
                  var openStatus
                  if (detailsID.localeCompare( details.id )===0 ){openStatus = !clickedStatus;}
                  else                                           {openStatus = details.open;}
                  if (openStatus){allCollapsed = false;}
                  else           {allExpanded  = false;}
              }
          }

          function in_iFrame ()
          {
               try {
                   return window.self !== window.top;
               } catch (e) {
                   return true;
               }
          }
</script>

</head>
<body>
<div class="content">
<div id="return-link" style="display:none;" class="tooltip">
<p onclick="jump_to()">
    <span onclick="jump_to()"><span id="up">&#8679;</span><span id="down">&#8681;</span>
    <span onclick="hide_back_link()" style="padding:2px; font-size:120%;" id="jump-close"><b onclick="hide_back_link()">&times;</b></span></span>
</p>
<div id="tooltiptext">click to return
<br>(click <b>&times;</b> to hide)</div>
</div><script>document.getElementById("dark-theme").sheet.disabled = true;</script>
<h1>Microscopy Image Browser Graphcut segmentation</h1>
<!--introduction-->
<p>This window give access to semi-automated image segmentation using the maxflow/mincut graphcut method.</p>
<p>The <b>Graph cut</b> segmentation is based on <a href="http://vision.csd.uwo.ca/code/">Max-flow/min-cut algorithm</a> written by Yuri Boykov and Vladimir Kolmogorov and implemented for MATLAB by <a href="http://www.mathworks.com/matlabcentral/fileexchange/21310-maxflow">Michael Rubinstein</a>. The max-flow/min-cut algorithm is applied not to individual pixels but to groups of pixels (superpixels (2D), or supervoxels(3D)) that may be generated either using the <a href="http://ivrl.epfl.ch/research/superpixels"><b>SLIC algorithm</b></a> written by Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine S?sstrunk or by the <b>Waterhed algorithm</b>. The objects that have intensity contrast are best described with the <i>SLIC superpixels</i>, while the objects that have distinct boundaries with the <i>Watershed superpixels</i>. Utilization of superpixels requires some time to calculate them but pays off during the following segmentation.</p>
<p>
<b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <code><b>--&gt;</b></code> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu.html"><b>Menu</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu_tools.html"><b>Tools Menu</b></a>
</p>
<!--/introduction-->
<p style="margin:0px; line-height:0;">&nbsp;</p>
<p onclick="toggle_details(0)" class="collapse-link"><a href="javascript:void(0);" id="Toggle0">collapse all on page</a></p><h2>Contents</h2>
<div>
<ul>
<li>
<my-a onclick="jump_to()" href="#2">General example</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#3">Mode panel</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#4">Subarea panel</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#5">Calculation of superpixels/supervoxels</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#6">Image segmentation settings</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#7">Image segmentation example</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#8">References</my-a>
</li>
</ul>
</div>
<p>
<img class="image-fit" src="images\menuToolsGraphcut_Overview.jpg" alt=""> </p>
<p style="margin:0px; line-height:0;">&nbsp;</p>
<p onclick="toggle_details(1)" class="collapse-link"><a href="javascript:void(0);" id="Toggle1">collapse all</a></p><h2 id="2">General example</h2>
<p>
A demonstration of the Graphcut segmentation is available in the following video:
<br>
<a href="https://youtu.be/dMeoIZPaDS4"><img class="image-fit" style="vertical-align:middle;" src="images\youtube2.png">
<br>https://youtu.be/dMeoIZPaDS4</a>
</p>
<details open onclick="state_check('1.1')" id="1.1"><summary> <b>How to use</b> </summary>
<div class="details-div">
<p></p>
<p>
<img class="image-fit" src="images\menuToolsWatershedGraphcut.jpg" alt=""> </p>
<p>How to use:</p>
<div>
<ol>
<li>Use two labels to mark areas that belong to background and the objects of interest</li>
<li>Start the Graphcut segmentation tool: <i>Menu-&gt;Tools-&gt;Semi-automatic segmentation Graphcut</i>
</li>
<li>Set one of the modes: <i>2D/3D</i>
</li>
<li>Define type of superpixels/supervoxels: <i>SLIC</i>, or <i>Watershed</i>
</li>
<li>Generate superpixels/supervoxels (<i>Press the <b>Superpixels/Graph</b> button</i>)</li>
<li>Check the size of the generated superpixels and modify the size if needed</li>
<li>Press the <b>Segment</b> button to start segmentation</li>
</ol>
</div>
<p>
<b>Note!</b> some functions have to be compiled, please check the <a href="im_browser_system_requirements.html">System Requirements page</a> for details.</p>

</div>
</details>
<br>
<p> <span style="line-height:8px; display:block; vertical-align:top">
<br></span></p>
<h2 id="3">Mode panel</h2>
<p>The <code>Mode panel</code> offers possibility to select a desired working mode for the segmentation.</p>

<table style="width: 800px; border: 0px; line-height:150%">
<tr>
<td style="border: 0px; width: 180px">
  <img class="image-fit" src="images\menuToolsGraphcut_Mode.jpg">
</td>
<td style="border: 0px">
<ul>
<li><span class="kbd">&#9673; <b>2D, current slice only</b></span>, performs segmentation on the slice that is currently shown
in <a href="ug_panel_im_view.html">the Image View panel</a></li>
<li><span class="kbd">&#9673; <b>2D, slice-by-slice</b></span>, performs 2D segmentation for each slice of the
dataset individually</li>
<li><span class="kbd">&#9673; <b>3D, volume</b></span>, performs 3D segmentation for complete or selected portion (<em>see Selected Area section below</em>) of the dataset</li>
<li><span class="kbd">&#9673; <b>3D, volume, grid</b></span>, a special mode of 3D graphcut, where the dataset is chopped into several subvolumes (defined by Chop edit boxes, see below) and the dataset which is centered
at the Image View panel is gets segmented (for convenience, turn on the marker of the center point, <span class="code">toolbar->center marker button</span>
<img class="image-fit" src="images\toolbar_center_marker.jpg">). Chopping of large volume into several small subvolumes (<em>e.g.</em>400x400x400 pixels allows effective interactive segmentation of this large volume
To segment all subvolumes press the <span class="kbd">Segment All</span> button</li>
</ul>
</td>
</tr>
</table>

<h2 id="4">Subarea panel</h2>
<p>The <code>Subarea panel</code> allows selection of the sub-area of the dataset for processing. If dataset is too big it can be processed in parts or binned using this panel.</p>

<table style="width: 800px; border: 0px; line-height:150%">
<tr>
<td style="border: 0px; width: 180px">
  <img class="image-fit" src="images\menuToolsWatershed_Subarea.jpg">
</td>
<td style="border: 0px">
<ul>
<li><span class="dropdown">X:...</span> defines the width of the dataset to process. Please use two numbers separated by a colon sign (:)</li>
<li><span class="dropdown">Y:...</span> defines the height of the dataset to process</li>
<li><span class="dropdown">Z:...</span> defines the z-slices of the dataset to process</li>
<li><span class="kbd">from Selection</span> button populates the <b>X:</b>, <b>Y:</b>, <b>Z:</b> fields
using coordinates of a bounding box that describes the <em>Selection</em> layer</li>
<li><span class="kbd">Current View</span> button limits the <b>X:</b> and <b>Y:</b> parameters to the image
that is currently displayed in the <a href="ug_panel_im_view.html"> Image View panel</a></li>
<li><span class="kbd">Reset</span> resets the Subarea fields to the dimensions of the dataset</li>
<li><span class="dropdown">Bin x times...</span> defines a binning factor for the data before segmentation.
It allows to perform faster but with less
details. 
<br><b>Attention!</b> The auto update mode (<span class="kbd">[&#10003;] <b>auto update</b></span>) is not available for the binned datasets!</li>
</ul>
</td>
</tr>
</table>

<p><span style="line-height:8px; display:block; vertical-align:top">
<br></span></p>
<p style="margin:0px; line-height:0;">&nbsp;</p>
<p onclick="toggle_details(2)" class="collapse-link"><a href="javascript:void(0);" id="Toggle2">collapse all</a></p><h2 id="5">Calculation of superpixels/supervoxels</h2>
<p>Before the segmentation, the pixels of the opened dataset should be clustered using the SLIC or Watershed algorithms. The picture below shows comparison between two types of superpixels. The upper panels show the <i>SLIC superpixels</i> that were good to segment a dark lipid droplet that has a good intensity contrast. The <i>Watershed superpixels</i> gave better segmentation of objects that were surrounded with boundaries.</p>
<details open onclick="state_check('2.1')" id="2.1"><summary> <b>Image example of clusters</b> </summary>
<div class="details-div">
<p></p>
<p>
<img class="image-fit" src="images\menuToolsWatershedGraphcut_slic_vs_watershed.jpg" alt=""> </p>

</div>
</details>
<br>
<p>
<img class="image-fit" src="images\menuToolsGraphcut_Superpixels.jpg" alt=""> </p>
<div>
<ul>
<li><span class="dropdown">Superpixels ▼</span>, define type of superpixels to use</li>
<li><span class="dropdown">Size of superpixels...</span>, defines approximate size of superpixels (<i>SLIC only</i>)</li>
<li><span class="dropdown">Compactness...</span>, a number between 1 and 99 that defines how square the superpixels should be; for example, 99 - results in quite square superpixels (<i>SLIC only</i>)</li>
<li><span class="dropdown">Reduce number of superpixels...</span>, a factor that is allowing to increase size of superpixels, the larger numbers results in larger superpixels (<i>Watershed only</i>)</li>
<li><span class="dropdown">Color channel ▼</span>, index of the color channel to be used for calculation of superpixels</li>
<li><span class="dropdown">Type of signal ▼</span>, use black-on-white for electron microscopy and light-on black for light microscopy</li>
<li>The <span class="dropdown">Chop...</span>editboxes, allow to chop the dataset into smaller subvolumes for the <span class="kbd">◉ <b>3D volume grid</b></span> mode or for calculation of the SLIC supervoxels</li>
<li>The <span class="kbd">[✓] <b>autosave</b></span> checkbox - when enabled, the resulting graphcut structure with the generated supervoxels is automatically saved to disk for future use</li>
<li>The <span class="kbd">[✓] <b>parfor</b></span> checkbox - when enabled, the Watershed clustering for the <b>3D volume grid</b> mode is calculated using the parallel processing, which improves calculation performance in several times</li>
<li><span class="kbd">[✓] <b>use PixelIdsList</b></span> - when enabled, the generation of final models is based on detected indices of supervoxels. This mode may improve performance in some situations, but requires more memory % <span class="kbd">Recalculate Graph</span> - allows to recalculate the graph using a new coefficient (<code>Coef</code>). In general, the larger coefficients give stronger growth from the seeds. Sometimes, however, the large coefficients results in segmentation of areas that are distant from the seeds, which is considered as an artefact of the method.</li>
<li><span class="kbd">Superpixels/Graph</span> press this button to initiate generation of superpixels and their final organization into a graph</li>
<li><span class="kbd">Import</span> press to import superpixels and the generated graph from a disk or MATLAB</li>
<li><span class="kbd">Export</span> press to export superpixels and the generated graph to a file, MATLAB, a new model or as Lines3D graph object (not recommended for many superpixels, see also here <a href="https://youtu.be/xrsTVqD7kOQ">https://youtu.be/xrsTVqD7kOQ</a>)</li>
<li><span class="kbd">Preview superpixels</span> the generated superpixels may be previewed by pressing this button</li>
</ul>
</div>
<h2 id="6">Image segmentation settings</h2>
<p>Both the <a href="ug_gui_menu_tools_watershed.html"><b>Watershed</b></a> and <b>Graphcut</b> workflows use provided labels that mark areas belonging to the Object and Background to perform the fine segmentation. Comparing to the <b>Graphcut</b> workflow, the <b>Watershed</b> workflow is a bit less interactive; it requires more time for the each execution and separates only objects that have distinct boundaries, for example membrane enclosed organelles.</p>
<p>On the other hand, the <b>Graphcut</b> workflow spends more time on the image preprocessing (calculation of the superpixels and generation of a graph) but each following interaction is fast. Using this workflow it is possible to separate objects that have both boundaries and intensity contrast. In general the <b>Graphcut workflow</b> is recommended for most of the cases.</p>
<p>Below, description of the <b>Image segmentation settings</b>:</p>

<table style="width: 800px; border: 0px; line-height:150%">
<tr>
<td style="border: 0px; width:400px">
  <img class="image-fit" src="images\menuToolsGraphcut_ImageSegmSettings.jpg">
</td>
<td style="border: 0px">
<ul>
<li><span class="dropdown">Background &#9660;</span> defines a material of the model that labels the
background areas</li>
<li><span class="dropdown">Object &#9660;</span> defines a material of the model that labels the
object to be segmented</li>
<li><span class="kbd">Update lists</span> refreshes the lists of materials</li>
<li><span class="kbd">[&#10003;] <b>Auto update</b></span> - enables auto update of the segmentation results each time when material is modified.
It is mostly useful for relatively small datasets (~400x400x400 pixels).
      
<br><b><em>Important:</b></em> please do not use the <span class="kbd">&#8679; Shift+A</span> key shortcut, but only <span class="kbd">A</span> shortcut.
      Also, when this mode is used it is recommended to
      recalculate the final segmentation by pressing the <span class="kbd">Segment</span> button. Also the auto update mode is not available if the <b>Bin</b> mode is used.</li>
</ul>
</td>
</tr>
</table>

<h2 id="7">Image segmentation example</h2>

<table style="width: 800px; border: 0px; line-height:150%">
<tr>
<td style="border: 0px">
  <img class="image-fit" src="images\watershed_imsegm_01.jpg">
</td>
<td style="border: 0px">
<ul>
<li>Load a sample dataset: <span class="code">Menu->File->Import image
from->URL</span>, enter the address:
<br>
http://mib.helsinki.fi/tutorials/WatershedDemo/watershed_demo1.tif</li>
<li>Press the <span class="kbd"><b>+</b></span> button in the <a href="ug_panel_segm.html">Segmentation panel</a> to add material to the model and name is as 'Background' (use the right mouse button to call a popup menu)</li>
<li>Use the brush tool to label an area that belongs to cytoplasm</li>
</ul>
</td>
</tr>
<tr><td colspan=2 style="border: 0px">
<img class="image-fit" src="images\watershed_imsegm_02.jpg">
</td></tr>
<tr><td colspan=2 style="border: 0px">
<ul>
<li>Press the <span class="kbd"><b>A</b></span> button to add selected area to the first material (Background) of the model</li>
<li>Press the <span class="kbd"><b>+</b></span> button again to add another material and name it as 'Seeds'</li>
<li>Draw labels inside mitochondria.</li>
</ul>
</td></tr>
<tr><td colspan=2 style="border: 0px">
<img class="image-fit" src="images\watershed_imsegm_03.jpg">
</td></tr>
<tr><td colspan=2 style="border: 0px">
<ul>
<li>Press the <span class="kbd"><b>A</b></span> button to add selected area to the second material (Seeds) of the model</li>
<li>Start the Graphcut segmentation tool: <span class="code">Menu->Tools->Semi-automatic segmentation->Graphcut</span>.</li>
<li>Select the <span class="dropdown">Watershed &#9660;</span> type of superpixels</li>
<li>Make sure that the proper materials are selected for both Background and Object in the <em>Image segmentation settings</em></li>
<li>Press the <span class="kbd">Segment</span> button to segment mitochondria</li>
<li>Add more seeds to the background and object materials to improve segmentaion</li>
<li>Press the <span class="kbd">Segment</span> button again of use the <span class="kbd">[&#10003;] <b>Auto update</b></span> mode
for instant update of the segmentation results</li>
<li>The segmented mitochondria are placed to the <em>Mask</em> layer</li>
<li>Optionally smooth mitochondria: <span class="code">Menu->Mask->Smooth Mask</span></li>
</ul>
</td></tr>
<tr><td colspan=2 style="border: 0px">
<img class="image-fit" src="images\watershed_imsegm_04.jpg">
</td></tr>
</table>

<h2 id="8">References</h2>
<p>Graph Cut:</p>
<div>
<ul>
<li> <a href="http://vision.csd.uwo.ca/code/"><b>Max-flow/min-cut algorithm</b></a> written by Yuri Boykov and Vladimir Kolmogorov (<b><i>Please note that this algorithm is licensed only for research purposes</i></b>).</li>
<li> <a href="http://www.mathworks.com/matlabcentral/fileexchange/21310-maxflow"><b>MATLAB wrapper</b></a> for maxflow is written by Michael Rubinstein.</li>
<li> <a href="http://ivrl.epfl.ch/research/superpixels"><b>SLIC superpixels and supervoxels</b></a> by Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine S?sstrunk.</li>
<li> <a href="http://www.mathworks.com/matlabcentral/fileexchange/16938-region-adjacency-graph--rag-"><b>Region Adjacency Graph (RAG)</b></a> and its modification for watershed was written by David Legland, INRA, France, 2013-2015 and was used in calculation of adjusent superpixels</li>
</ul>
</div>
<p>
<b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <code><b>--&gt;</b></code> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu.html"><b>Menu</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu_tools.html"><b>Tools Menu</b></a>
</p>
<p></p>
<p>
<script>
  var allDetails = document.getElementsByTagName('details');
  toggle_details(0);
</script>
</p>
<p class="footer">

<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a> and subsequently processed by <a class="pretty-link" href="https://www.mathworks.com/matlabcentral/fileexchange/78059-prettify-matlab-html">prettify_MATLAB_html</a> V6.8b2</p>
<p id="iFrameBuf">&nbsp;</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Microscopy Image Browser Graphcut segmentation
% This window give access to semi-automated image segmentation using the
% maxflow/mincut graphcut method. 
%
%
% The *Graph cut* segmentation is based on <http://vision.csd.uwo.ca/code/ Max-flow/min-cut algorithm>
% written by Yuri Boykov and Vladimir Kolmogorov and implemented for MATLAB by 
% <http://www.mathworks.com/matlabcentral/fileexchange/21310-maxflow Michael Rubinstein>. 
% The max-flow/min-cut algorithm is applied not
% to individual pixels but to groups of pixels (superpixels (2D), or supervoxels(3D)) that may be generated either using
% the <http://ivrl.epfl.ch/research/superpixels *SLIC algorithm*> written by Radhakrishna Achanta, 
% Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine
% S?sstrunk or by the *Waterhed algorithm*. The objects that have intensity
% contrast are best described with the _SLIC superpixels_, while the objects
% that have distinct boundaries with the _Watershed superpixels_. Utilization of superpixels requires some time to calculate
% them but pays off during the following segmentation.
% 
%
% 
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> 
% |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu.html *Menu*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu_tools.html *Tools Menu*>
% 
%%
%
% <<images\menuToolsGraphcut_Overview.jpg>>
%
%% General example
%
%
% <html lang="en">
% A demonstration of the Graphcut segmentation is available in the following video:
<br>
% <a href="https://youtu.be/dMeoIZPaDS4"><img style="vertical-align:middle;" src="images\youtube2.png">
<br>https://youtu.be/dMeoIZPaDS4</a>
% </html>
%
% [dtls]<summary> *How to use* </summary>
<div class="details-div">
% 
% <<images\menuToolsWatershedGraphcut.jpg>>
% 
%
% How to use:
% 
% # Use two labels to mark areas that belong to background and the objects of interest
% # Start the Graphcut segmentation tool: _Menu->Tools->Semi-automatic segmentation Graphcut_
% # Set one of the modes: _2D/3D_
% # Define type of superpixels/supervoxels: _SLIC_, or _Watershed_
% # Generate superpixels/supervoxels (_Press the *Superpixels/Graph* button_)
% # Check the size of the generated superpixels and modify the size if needed
% # Press the *Segment* button to start segmentation
%
% *Note!* some functions have to be compiled, please check the <im_browser_system_requirements.html System
% Requirements page> for details.
%
% [/dtls]
% [br8]
%
%% Mode panel
% The |Mode panel| offers possibility to select a desired working mode for
% the segmentation. 
% 
% <html lang="en">
% <table style="width: 800px; border: 0px; line-height:150%">
% <tr>
% <td style="border: 0px; width: 180px">
%   <img src="images\menuToolsGraphcut_Mode.jpg">
% </td>
% <td style="border: 0px">
% <ul>
% <li><span class="kbd">&#9673; <b>2D, current slice only</b></span>, performs segmentation on the slice that is currently shown
% in <a href="ug_panel_im_view.html">the Image View panel</a></li>
% <li><span class="kbd">&#9673; <b>2D, slice-by-slice</b></span>, performs 2D segmentation for each slice of the
% dataset individually</li>
% <li><span class="kbd">&#9673; <b>3D, volume</b></span>, performs 3D segmentation for complete or selected portion (<em>see Selected Area section below</em>) of the dataset</li>
% <li><span class="kbd">&#9673; <b>3D, volume, grid</b></span>, a special mode of 3D graphcut, where the dataset is chopped into several subvolumes (defined by Chop edit boxes, see below) and the dataset which is centered 
% at the Image View panel is gets segmented (for convenience, turn on the marker of the center point, <span class="code">toolbar->center marker button</span> 
% <img src="images\toolbar_center_marker.jpg">). Chopping of large volume into several small subvolumes (<em>e.g.</em>400x400x400 pixels allows effective interactive segmentation of this large volume
% To segment all subvolumes press the <span class="kbd">Segment All</span> button</li>
% </ul>
% </td>
% </tr>
% </table>
% </html>
%
%
%% Subarea panel
% The |Subarea panel| allows selection of the sub-area of the dataset for
% processing. If dataset is too big it can be processed in parts or binned
% using this panel.
% 
% <html lang="en">
% <table style="width: 800px; border: 0px; line-height:150%">
% <tr>
% <td style="border: 0px; width: 180px">
%   <img src="images\menuToolsWatershed_Subarea.jpg">
% </td>
% <td style="border: 0px">
% <ul>
% <li><span class="dropdown">X:...</span> defines the width of the dataset to process. Please use two numbers separated by a colon sign (:)</li>
% <li><span class="dropdown">Y:...</span> defines the height of the dataset to process</li>
% <li><span class="dropdown">Z:...</span> defines the z-slices of the dataset to process</li>
% <li><span class="kbd">from Selection</span> button populates the <b>X:</b>, <b>Y:</b>, <b>Z:</b> fields
% using coordinates of a bounding box that describes the <em>Selection</em> layer</li>
% <li><span class="kbd">Current View</span> button limits the <b>X:</b> and <b>Y:</b> parameters to the image
% that is currently displayed in the <a href="ug_panel_im_view.html"> Image View panel</a></li>
% <li><span class="kbd">Reset</span> resets the Subarea fields to the dimensions of the dataset</li>
% <li><span class="dropdown">Bin x times...</span> defines a binning factor for the data before segmentation. 
% It allows to perform faster but with less
% details. 
<br><b>Attention!</b> The auto update mode (<span class="kbd">[&#10003;] <b>auto update</b></span>) is not available for the binned datasets!</li>
% </ul>
% </td>
% </tr>
% </table>
% </html>
%
% [br8]
% 
%% Calculation of superpixels/supervoxels
%
% Before the segmentation, the pixels of the opened dataset should be
% clustered using the SLIC or Watershed algorithms.
% The picture below shows comparison between two types of superpixels. The
% upper panels show the _SLIC superpixels_ that were good to segment a dark
% lipid droplet that has a good intensity contrast. The _Watershed
% superpixels_ gave better segmentation of objects  that were surrounded
% with boundaries.
%
% [dtls]<summary> *Image example of clusters* </summary>
<div class="details-div">
% 
% <<images\menuToolsWatershedGraphcut_slic_vs_watershed.jpg>>
%
% [/dtls]
% 
% <<images\menuToolsGraphcut_Superpixels.jpg>>
%
% * [class.dropdown]Superpixels &#9660;[/class], define type of superpixels to use
% * [class.dropdown]Size of superpixels...[/class], defines approximate size of superpixels (_SLIC only_)
% * [class.dropdown]Compactness...[/class], a number between 1 and 99 that defines how square the
% superpixels should be; for example, 99 - results in quite square superpixels (_SLIC only_)
% * [class.dropdown]Reduce number of superpixels...[/class], a factor that is allowing to increase
% size of superpixels, the larger numbers results in larger superpixels (_Watershed only_)
% * [class.dropdown]Color channel &#9660;[/class], index of the color channel to be used for calculation of superpixels
% * [class.dropdown]Type of signal &#9660;[/class], use black-on-white for electron microscopy and
% light-on black for light microscopy
% * The [class.dropdown]Chop...[/class]editboxes, allow to chop the dataset into smaller subvolumes for the [class.kbd]&#9673; *3D volume grid*[/class] mode
% or for calculation of the SLIC supervoxels
% * The [class.kbd][&#10003;] *autosave*[/class] checkbox - when enabled, the resulting graphcut structure
% with the generated supervoxels is automatically saved to disk for future use
% * The [class.kbd][&#10003;] *parfor*[/class] checkbox - when enabled, the Watershed clustering for the *3D volume grid* mode is
% calculated using the parallel processing, which improves calculation
% performance in several times
% * [class.kbd][&#10003;] *use PixelIdsList*[/class] - when enabled, the generation of final models is
% based on detected indices of supervoxels. This mode may improve
% performance in some situations, but requires more memory
% % [class.kbd]Recalculate Graph[/class] - allows to recalculate the graph using a new
% coefficient (|Coef|). In general, the larger coefficients give stronger
% growth from the seeds. Sometimes, however, the large coefficients results
% in segmentation of areas that are distant from the seeds, which is
% considered as an artefact of the method.
% * [class.kbd]Superpixels/Graph[/class] press this button to initiate generation of superpixels and their final organization into a graph
% * [class.kbd]Import[/class] press to import superpixels and the generated graph from a disk or MATLAB
% * [class.kbd]Export[/class] press to export superpixels and the generated graph to a file,
% MATLAB, a new model or as Lines3D graph object (not recommended for many superpixels, see also here
% https://youtu.be/xrsTVqD7kOQ)
% * [class.kbd]Preview superpixels[/class] the generated superpixels may be previewed by pressing this button
%
%
%% Image segmentation settings
% Both the <ug_gui_menu_tools_watershed.html *Watershed*> and *Graphcut* workflows use provided labels that
% mark areas belonging to the Object and Background to perform the fine
% segmentation. Comparing to the *Graphcut* workflow, the *Watershed* workflow is a bit less interactive; it
% requires more time for the each execution and separates only objects that have distinct boundaries, 
% for example membrane enclosed organelles. 
%
% On the other hand, the *Graphcut* workflow spends more time on the image preprocessing (calculation of the superpixels and generation of a graph) but each following
% interaction is fast. Using this workflow it is possible to separate objects that have both boundaries and intensity contrast. In general the *Graphcut workflow* is recommended
% for most of the cases. 
%
% Below, description of the *Image segmentation settings*:
%
% <html lang="en">
% <table style="width: 800px; border: 0px; line-height:150%">
% <tr>
% <td style="border: 0px; width:400px">
%   <img src="images\menuToolsGraphcut_ImageSegmSettings.jpg">
% </td>
% <td style="border: 0px">
% <ul>
% <li><span class="dropdown">Background &#9660;</span> defines a material of the model that labels the
% background areas</li>
% <li><span class="dropdown">Object &#9660;</span> defines a material of the model that labels the
% object to be segmented</li>
% <li><span class="kbd">Update lists</span> refreshes the lists of materials</li>
% <li><span class="kbd">[&#10003;] <b>Auto update</b></span> - enables auto update of the segmentation results each time when material is modified. 
% It is mostly useful for relatively small datasets (~400x400x400 pixels). 
%       
<br><b><em>Important:</b></em> please do not use the <span class="kbd">&#8679; Shift+A</span> key shortcut, but only <span class="kbd">A</span> shortcut. 
%       Also, when this mode is used it is recommended to 
%       recalculate the final segmentation by pressing the <span class="kbd">Segment</span> button. Also the auto update mode is not available if the <b>Bin</b> mode is used.</li>
% </ul>
% </td>
% </tr>
% </table>
% </html>
% 
%% Image segmentation example
%
% <html lang="en">
% <table style="width: 800px; border: 0px; line-height:150%">
% <tr>
% <td style="border: 0px">
%   <img src="images\watershed_imsegm_01.jpg">
% </td>
% <td style="border: 0px">
% <ul>
% <li>Load a sample dataset: <span class="code">Menu->File->Import image
% from->URL</span>, enter the address:
<br>
% http://mib.helsinki.fi/tutorials/WatershedDemo/watershed_demo1.tif</li>
% <li>Press the <span class="kbd"><b>+</b></span> button in the <a href="ug_panel_segm.html">Segmentation panel</a> to add material to the model and name is as 'Background' (use the right mouse button to call a popup menu)</li>
% <li>Use the brush tool to label an area that belongs to cytoplasm</li>
% </ul>
% </td>
% </tr>
% <tr><td colspan=2 style="border: 0px">
% <img src="images\watershed_imsegm_02.jpg"> 
% </td></tr>
% <tr><td colspan=2 style="border: 0px">
% <ul>
% <li>Press the <span class="kbd"><b>A</b></span> button to add selected area to the first material (Background) of the model</li>
% <li>Press the <span class="kbd"><b>+</b></span> button again to add another material and name it as 'Seeds'</li>
% <li>Draw labels inside mitochondria.</li>
% </ul>
% </td></tr>
% <tr><td colspan=2 style="border: 0px">
% <img src="images\watershed_imsegm_03.jpg"> 
% </td></tr>
% <tr><td colspan=2 style="border: 0px">
% <ul>
% <li>Press the <span class="kbd"><b>A</b></span> button to add selected area to the second material (Seeds) of the model</li>
% <li>Start the Graphcut segmentation tool: <span class="code">Menu->Tools->Semi-automatic segmentation->Graphcut</span>.</li>
% <li>Select the <span class="dropdown">Watershed &#9660;</span> type of superpixels</li>
% <li>Make sure that the proper materials are selected for both Background and Object in the <em>Image segmentation settings</em></li>
% <li>Press the <span class="kbd">Segment</span> button to segment mitochondria</li>
% <li>Add more seeds to the background and object materials to improve segmentaion</li>
% <li>Press the <span class="kbd">Segment</span> button again of use the <span class="kbd">[&#10003;] <b>Auto update</b></span> mode 
% for instant update of the segmentation results</li>
% <li>The segmented mitochondria are placed to the <em>Mask</em> layer</li>
% <li>Optionally smooth mitochondria: <span class="code">Menu->Mask->Smooth Mask</span></li>
% </ul>
% </td></tr>
% <tr><td colspan=2 style="border: 0px">
% <img src="images\watershed_imsegm_04.jpg"> 
% </td></tr>
% </table>
% </html>
%
%% References
% 
% Graph Cut:
%
% * <http://vision.csd.uwo.ca/code/ *Max-flow/min-cut algorithm*> written by Yuri Boykov and Vladimir Kolmogorov (*_Please note that this algorithm is licensed only
% for research purposes_*). 
% * <http://www.mathworks.com/matlabcentral/fileexchange/21310-maxflow *MATLAB
% wrapper*> for maxflow is written by Michael Rubinstein.
% * <http://ivrl.epfl.ch/research/superpixels *SLIC superpixels and supervoxels*> by Radhakrishna Achanta, 
% Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine S?sstrunk. 
% * <http://www.mathworks.com/matlabcentral/fileexchange/16938-region-adjacency-graphREPLACE_WITH_DASH_DASHrag- *Region Adjacency Graph (RAG)*> and its modification for watershed 
% was written by David Legland, INRA, France, 2013-2015 and was used in
% calculation of adjusent superpixels
%
%
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> 
% |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu.html *Menu*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu_tools.html *Tools Menu*>
%
%
% [cssClasses]
% .dropdown { 
%   font-family: monospace;
% 	border: 1px solid #aaa; 
% 	border-radius: 0.2em; 
% 	background-color: #fff; 
% 	background-color: #e0f5ff; 
% 	background-color: #e8f5e8; 
% 	padding: 0.1em 0.4em; 
% 	font-family: inherit; 
% 	font-size: 1em;
% }
% .kbd { 
%   font-family: monospace;
% 	border: 1px solid #aaa; 
% 	-moz-border-radius: 0.2em; 
% 	-webkit-border-radius: 0.2em; 
% 	border-radius: 0.2em; 
% 	-moz-box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	-webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	background-color: #f9f9f9; 
% 	background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: linear-gradient(&#91;&#91;:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); 
% 	padding: 0.1em 0.4em; 
% 	font-family: inherit; 
% 	font-size: 1em;
% }
% .h3 {
% color: #E65100;
% font-size: 12px;
% font-weight: bold;
% }
% .code {
% font-family: monospace;
% font-size: 10pt;
% background: #eee;
% padding: 1pt 3pt;
% }
% [/cssClasses]
%%
% <html lang="en">
% <script>
%   var allDetails = document.getElementsByTagName('details');
%   toggle_details(0);
% </script>
% </html>
##### SOURCE END #####
-->
<script>
var allDetails   = document.getElementsByTagName('details');
var contentDiv   = document.getElementsByClassName("content"); contentDiv = contentDiv[0];
var returnButton = document.getElementById("return-link");
document.getElementById("iFrameBuf").style.display = "none";
if(in_iFrame())
{
   try{
      var footerNav = parent.document.getElementsByClassName("footernav");
      var tabPane   = parent.document.getElementsByClassName("tab-pane");}
   catch(err) { var footerNav = []; var tabPane = [];};
   if(!(footerNav.length) || tabPane.length)
   {
      contentDiv.style.overflowY = "scroll";
      contentDiv.style.overflowX = "hidden";
      contentDiv.style.position  = "absolute";
      contentDiv.style.width     = "95%";
      contentDiv.style.top       = 0;
      contentDiv.style.bottom    = 0;
      if (tabPane.length){
         contentDiv.setAttribute("data-isMATLABCentral","1");
         returnButton.style.right = "40px";
         document.getElementById("tooltiptext").style.right = "92px"; }
      document.getElementById("iFrameBuf").style.display = "block";
   }
   else { contentDiv.setAttribute("data-isHelpBrowser","1"); }
}
if (!contentDiv.getAttribute("data-isHelpBrowser") && !contentDiv.getAttribute("data-isMATLABCentral") ){
   document.getElementById("anchor-offsets").sheet.disabled = true; }
</script></body>
</html>
