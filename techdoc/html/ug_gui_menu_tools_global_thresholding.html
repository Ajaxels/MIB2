
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Global black-and-white thresholding</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-04-27"><meta name="DC.source" content="ug_gui_menu_tools_global_thresholding.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Global black-and-white thresholding</h1><!--introduction--><p>Perform global black-and-white thresholding of the dataset.</p><p><b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <tt><b>--&gt;</b></tt> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <tt><b>--&gt;</b></tt> <a href="ug_gui_menu.html"><b>Menu</b></a> <tt><b>--&gt;</b></tt> <a href="ug_gui_menu_tools.html"><b>Tools</b></a></p><p>
A demonstration of the global black-and-white thresholding is available in the following video:<br>
<a href="https://youtu.be/mzfgxLvkGTI"><img style="vertical-align:middle;" src="images\youtube2.png"><br>https://youtu.be/mzfgxLvkGTI</a>
</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">CONCAVITY algorithm</a></li><li><a href="#3">ENTROPY algorithm</a></li><li><a href="#6">INTERMEANS ITER algorithm</a></li><li><a href="#7">INTERMODES algorithm</a></li><li><a href="#8">MEAN algorithm</a></li><li><a href="#9">MEDIAN and PERCENTILE algorithms</a></li><li><a href="#10">MINERROR algorithm</a></li><li><a href="#11">MINERROR ITER algorithm</a></li><li><a href="#12">MINIMUM algorithm</a></li><li><a href="#13">MOMENTS algorithm</a></li><li><a href="#14">OTSU algorithm</a></li><li><a href="#15">Programming tips</a></li></ul></div><p><img vspace="5" hspace="5" src="images/menuToolsSemiautoSegmAutomaticThresholding.png" alt=""> </p><h2 id="2">CONCAVITY algorithm</h2><div><ul><li>If the image does not have distinct objects and background, the MINIMUM and INTERMODES algorithms are not suitable.</li><li>A good threshold may be found at the shoulder of the histogram.</li><li>The shoulder location can be found based on the concavity of the histogram.</li><li>Construct the convex hull H of the histogram y.</li><li>Find the local maxima of <tt>H - y</tt>.</li><li>Set <tt>t</tt> to the value of <tt>j</tt> at which the balance measure <tt>bj = Aj(An - Aj)</tt> is maximized</li><li>The algorithm seems to work well in many cases, but in some cases it gives thresholds that are clearly unusable</li></ul></div><p><b>Reference</b> A. Rosenfeld and P. De La Torre, Histogram concavity analysis as an aid in threshold selection, IEEE Trans. Systems Man Cybernet., vol. 13, pp. 231-235, 1983</p><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="3">ENTROPY algorithm</h2><div><ul><li>One of several maximum entropy algorithms</li><li>Divides the histogram of the image into two probability distributions, one representing the objects and one representing the background</li><li>Choose t such that the sum of the entropies of these probability distributions is maximized</li><li>Define the partial sums:</li></ul></div><p><img src="ug_gui_menu_tools_global_thresholding_eq17198354827927193183.png" alt="$E_{j} =\sum_{i=0}^{j}y_{i}\cdot \textup{log}y_{i}, \textup{for} j=0, ..., n$"></p><div><ul><li>Set t to the value of j at which an equiation below is maximized</li></ul></div><p><img src="ug_gui_menu_tools_global_thresholding_eq15156630708765486835.png" alt="$\frac{E_{j}}{A_{j}} - \textup{log}A_{j} + \frac{E_{n} - E_{j}}{A_{n} - A_{j}} - \textup{log}A_{n} - A_{j}$"></p><p><b>Reference</b></p><div><ul><li>J. N. Kapur, P. K. Sahoo, and A. K. C. Wong, A new method for gray-level picture thresholding using the entropy of the histogram, Comput. Vision Graphics Image Process., vol. 29, pp. 273-285, 1985.</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="6">INTERMEANS ITER algorithm</h2><div><ul><li>An iterative algorithm that gives similar results as the OTSU algorithm</li><li>Computationally less intensive than OTSU</li><li>The algorithm starts with an initial guess for <tt>t</tt></li><li>Define the means &#956;t and &#957;t of the two classes</li><li>Set <tt>t = [(&#956;t + &#957;t)/2]</tt> and recalculate &#956;t and &#957;t.</li><li>Repeat until <tt>t</tt> has the same value in two consecutive iterations</li><li>The obtained t may strongly depend on its initial value</li><li>If the objects and background occupy comparable areas, use MEAN</li><li>If the objects are small compared to the background, use INTERMODES.</li></ul></div><p><b>References</b></p><div><ul><li>T. Ridler and S. Calvard, Picture thresholding using an iterative selection method, IEEE Trans. Systems Man Cybernet., vol. 8, pp. 630-632, 1978.</li><li>H. J. Trussell, Comments on ?Picture thresholding using an iterative selection method?, IEEE Trans. Systems Man Cybernet., vol. 9, p. 311, 1979.</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="7">INTERMODES algorithm</h2><div><ul><li>An alternative to MINIMUM</li><li>Assumes a bimodal histogram</li><li>Find the two peaks (local maxima) <tt>yj</tt> and <tt>yk</tt></li><li>Set <tt>t</tt> to <tt>(j + k)/2</tt></li><li>Set <tt>t = [(&#956;t + &#957;t)/2]</tt> and recalculate &#956;t and &#957;t.</li><li>Still unsuitable for images that have a histogram with extremely unequal peaks</li></ul></div><p><b>Reference</b></p><div><ul><li>J. M. S. Prewitt and M. L. Mendelsohn, The analysis of cell images, in Ann. New York Acad. Sci., vol. 128, pp. 1035-1053, 1966</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="8">MEAN algorithm</h2><div><ul><li>Similar to the MEDIAN algorithm</li><li>Instead of median, set <tt>t</tt> such that it is the integer part of the mean of all pixel values</li><li>With the partial sum notation, <tt>t = Bn/An</tt></li><li>Does not take into account histogram shape, so obviously the results are suboptimal</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="9">MEDIAN and PERCENTILE algorithms</h2><div><ul><li>Assumes that the percentage of object pixels is known</li><li>Set <tt>t</tt> to the highest gray-level which maps at least <tt>(100 - p)%</tt> of the pixels into the object category</li><li>Not suitable if the object area is not know</li><li>Problem: the algorithm is parametric</li><li>Solution: set <tt>p = 50</tt> so that <tt>t</tt> is the median of the distribution of pixel values</li></ul></div><p><b>Reference</b></p><div><ul><li>W. Doyle, Operation useful for similarity-invariant pattern recognition, J. Assoc. Comput. Mach, vol. 9, pp. 259-267, 1962</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="10">MINERROR algorithm</h2><div><ul><li>Similar to the OTSU algorithm</li><li>Views the histogram as an estimate of the probability density function of the mixture population (objects and background)</li><li>Assumes a Gaussian mixture model, that is, <b>A)</b> the pixels in the two categories come from a normal distribution and <b>B)</b> the normal distributions may have different means as well as variances</li><li>Define the following statistics:</li></ul></div><p><img src="ug_gui_menu_tools_global_thresholding_eq07081496650412715374.png" alt="$p_{t} = \frac{A_{t}}{A_{n}}, q_{t} = \frac{A_{n} - A_{f}}{A_{n}}$"></p><p><img src="ug_gui_menu_tools_global_thresholding_eq15700027732760531580.png" alt="$\sigma{_{t}}^{2} = \frac{C_{t}}{A_{t}} - \mu{_{t}}^2, \tau{_{t}^{2}} = \frac{C_{n} - C_{t}}{A_{n} - A_{t}} - \nu{_{t}^2}$"></p><div><ul><li>Set <tt>t</tt> to the value of <tt>j</tt> at which   <img src="ug_gui_menu_tools_global_thresholding_eq11553214331305670307.png" alt="$p_{j}\textup{log}\begin{pmatrix}\sigma_{j}\\p_{j}\end{pmatrix} + q_{j}\textup{log}\begin{pmatrix}\tau_{j}\\q_{i}\end{pmatrix}$">  is minumized</li></ul></div><p><b>Reference</b></p><div><ul><li>J. Kittler and J. Illingworth, Minimum error thresholding, Pattern Recognition, vol. 19, pp. 41-47, 1986</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="11">MINERROR ITER algorithm</h2><div><ul><li>The iterative version of the MINERROR algorithm is computationally less intensive</li><li>Find initial value for <tt>t</tt> using MEAN</li><li>The integer part of the larger solution provides a new value <tt>t</tt>:</li></ul></div><p><img src="ug_gui_menu_tools_global_thresholding_eq15138001015028421859.png" alt="$x^{2}(\frac{1}{\sigma^{2}} - \frac{1}{\tau^{2}}) - 2x(\frac{\mu}{\sigma^{2}} + \frac{\nu}{\tau^{2}}) + (\frac{\mu^{2}}{\sigma^{2}} - \frac{\nu^{2}}{\tau^{2}} + \textup{log}(\frac{\sigma^{2}q^{2}}{\tau^{2}p^{2}})) = 0$"></p><div><ul><li>Let w0, w1 and w2 denote the three terms</li><li>Set <img src="ug_gui_menu_tools_global_thresholding_eq04035367692988784289.png" alt="$t = \frac{w_{1} + \sqrt{ {w_{1}}^{2} - w_{0}w_{2}}}{w_{0}}$"></li><li>Recalculate all the terms using the new value of <tt>t</tt> and re-derive <tt>t</tt></li><li>Repeat until convergence</li><li>This minimizes the number of misclassi?cations between the two normal distributions with the given means, variances, and proportions</li><li>The algorithm fails to converge if the quadratic equation does not have a real solution</li></ul></div><p><b>Reference</b></p><div><ul><li>J. Kittler and J. Illingworth, Minimum error thresholding, Pattern Recognition, vol. 19, pp. 41-47, 1986</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="12">MINIMUM algorithm</h2><div><ul><li>Assumes a bimodal histogram</li><li>The histogram needs to be smoothed (using the three-point mean filter) iteratively until the histogram has only two local maxima</li><li>Choose <tt>t</tt> such that <tt>yt - 1 &gt; yt ? yt + 1</tt></li><li>Unsuitable for images that have a histogram with extremely unequal peaks or a broad and flat valley</li></ul></div><p><b>Reference</b></p><div><ul><li>J. M. S. Prewitt and M. L. Mendelsohn, The analysis of cell images, in Ann. New York Acad. Sci., vol. 128, pp. 1035-1053, 1966</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="13">MOMENTS algorithm</h2><div><ul><li>Choose <tt>t</tt> such that the binary image has the same ?rst three moments as the gray-level image</li><li>his is achieved by setting <tt>t</tt> such that <tt>At/An</tt> is the value of the fraction nearest to <tt>x0</tt>, where</li></ul></div><p><img src="ug_gui_menu_tools_global_thresholding_eq01215381683744085270.png" alt="$x_{0} = \frac{1}{2} - \frac{B_{n}/A_{n} + x_{2}/2}{\sqrt{x_{2}^{2} - 4x_{1}}}, x_1 = \frac{B_{n}D_{n} - C_{n}^{2}}{A_{n}C_{n} - B_{n}2'}$"></p><p><img src="ug_gui_menu_tools_global_thresholding_eq06291206106226510118.png" alt="$x_{2} = \frac{B_{n}C_{n} - A_{n}D_{n}}{A_{n}C_{n} - B_{n}^{2}}, D_{n} = \sum_{i=0}^{n}i^{2}y_{i}$"></p><p><b>Reference</b></p><div><ul><li>W. Tsai, Moment-preserving thresholding: a new approach, Comput. Vision Graphics Image Process., vol. 29, pp. 377-393, 1985</li></ul></div><p><b>Acknowledgements</b> Based on the <a href="https://github.com/carandraug/histthresh">HistThresh Toolbox</a> by Antti Niemist&ouml;, Tampere University of Technology, Finland</p><h2 id="14">OTSU algorithm</h2><div><ul><li>Matlab implementation of the Otsu algorithm</li><li>The <tt>t</tt> value is calculated using <tt>graythresh</tt></li></ul></div><p><b>Reference</b></p><div><ul><li>Otsu, N., "A Threshold Selection Method from Gray-Level Histograms," IEEE Transactions on Systems, Man, and Cybernetics, Vol. 9, No. 1, 1979, pp. 62-66.</li></ul></div><h2 id="15">Programming tips</h2><p>This function is compatible with the batch scripting.</p><div><ul><li>Define parameters as a structure, where the names of the fields can be checked from the tooltips of the widgets</li><li>Some of the parameters are optional</li><li>use mibController.startController function, where the 3rd input is the defined structure with parameters</li></ul></div><p>For example,</p><pre class="language-matlab">BatchOpt.colChannel = 2;    <span class="comment">% define color channel for thresholding</span>
BatchOpt.Mode = <span class="string">'3D, Stack'</span>;     <span class="comment">% mode to use</span>
BatchOpt.Method = <span class="string">'Otsu'</span>;       <span class="comment">% thresholding algorithm</span>
BatchOpt.Destination = <span class="string">'selection'</span>;       <span class="comment">% [optional] destination layer, 'mask' or 'selection'</span>
BatchOpt.t = [1 1];     <span class="comment">% [optional] time points, [t1, t2]</span>
BatchOpt.z = [10 20];    <span class="comment">% [optional] slices, [z1, z2]</span>
BatchOpt.x = [10 120];    <span class="comment">% [optional] part of the image, [z1, z2]</span>
BatchOpt.Orientation = 4;      <span class="comment">% [optional], dataset orientation</span>
obj.startController(<span class="string">'mibHistThresController'</span>, [], BatchOpt);  <span class="comment">% start the thresholding</span>
</pre><p><b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <tt><b>--&gt;</b></tt> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <tt><b>--&gt;</b></tt> <a href="ug_gui_menu.html"><b>Menu</b></a> <tt><b>--&gt;</b></tt> <a href="ug_gui_menu_tools.html"><b>Tools</b></a></p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Global black-and-white thresholding
% Perform global black-and-white thresholding of the dataset. 
%
%
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu.html *Menu*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu_tools.html *Tools*>
%
%
% <html>
% A demonstration of the global black-and-white thresholding is available in the following video:<br>
% <a href="https://youtu.be/mzfgxLvkGTI"><img style="vertical-align:middle;" src="images\youtube2.png"><br>https://youtu.be/mzfgxLvkGTI</a>
% </html>
%
%%
%
% <<images/menuToolsSemiautoSegmAutomaticThresholding.png>>
% 
%% CONCAVITY algorithm
% 
% * If the image does not have distinct objects and background, the MINIMUM and INTERMODES 
% algorithms are not suitable.
% * A good threshold may be found at the shoulder of the histogram.
% * The shoulder location can be found based on the concavity of the histogram.
% * Construct the convex hull H of the histogram y.
% * Find the local maxima of |H - y|.
% * Set |t| to the value of |j| at which the balance measure |bj = Aj(An - Aj)| is maximized
% * The algorithm seems to work well in many cases, but in some cases it gives thresholds that are clearly unusable
%
% *Reference*
% A. Rosenfeld and P. De La Torre, Histogram concavity analysis as an aid
% in threshold selection, IEEE Trans. Systems Man Cybernet., vol. 13,
% pp. 231-235, 1983
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%% ENTROPY algorithm
% 
% * One of several maximum entropy algorithms
% * Divides the histogram of the image into two probability distributions, one representing the
% objects and one representing the background
% * Choose t such that the sum of the entropies of these probability distributions is maximized
% * Define the partial sums:
%%
% $E_{j} =\sum_{i=0}^{j}y_{i}\cdot \textup{log}y_{i}, \textup{for} j=0, ..., n$
%
% * Set t to the value of j at which an equiation below is maximized
%%
% $\frac{E_{j}}{A_{j}} - \textup{log}A_{j} + \frac{E_{n} - E_{j}}{A_{n} - A_{j}} - \textup{log}A_{n} - A_{j}$
% 
%
% *Reference*
%
% * J. N. Kapur, P. K. Sahoo, and A. K. C. Wong, A new method for
% gray-level picture thresholding using the entropy of the histogram,
% Comput. Vision Graphics Image Process., vol. 29, pp. 273-285, 1985.
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%% INTERMEANS ITER algorithm
% 
% * An iterative algorithm that gives similar results as the OTSU algorithm
% * Computationally less intensive than OTSU
% * The algorithm starts with an initial guess for |t|
% * Define the means &mu;t and &nu;t of the two classes
% * Set |t = [(&mu;t + &nu;t)/2]| and recalculate &mu;t and &nu;t.
% * Repeat until |t| has the same value in two consecutive iterations
% * The obtained t may strongly depend on its initial value
% * If the objects and background occupy comparable areas, use MEAN
% * If the objects are small compared to the background, use INTERMODES.
%
% *References*
%
% * T. Ridler and S. Calvard, Picture thresholding using an iterative selection
% method, IEEE Trans. Systems Man Cybernet., vol. 8, pp. 630-632, 1978.
% * H. J. Trussell, Comments on ?Picture thresholding using an iterative
% selection method?, IEEE Trans. Systems Man Cybernet., vol. 9, p. 311, 1979.
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%
%
%% INTERMODES algorithm
% 
% * An alternative to MINIMUM
% * Assumes a bimodal histogram
% * Find the two peaks (local maxima) |yj| and |yk|
% * Set |t| to |(j + k)/2|
% * Set |t = [(&mu;t + &nu;t)/2]| and recalculate &mu;t and &nu;t.
% * Still unsuitable for images that have a histogram with extremely unequal peaks
%
% *Reference*
%
% * J. M. S. Prewitt and M. L. Mendelsohn, The analysis of cell images, in
% Ann. New York Acad. Sci., vol. 128, pp. 1035-1053, 1966
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%% MEAN algorithm
% 
% * Similar to the MEDIAN algorithm
% * Instead of median, set |t| such that it is the integer part of the mean of all pixel values
% * With the partial sum notation, |t = Bn/An|
% * Does not take into account histogram shape, so obviously the results are suboptimal
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%
%
%% MEDIAN and PERCENTILE algorithms
% 
% * Assumes that the percentage of object pixels is known
% * Set |t| to the highest gray-level which maps at least |(100 - p)%| of the pixels into the object category
% * Not suitable if the object area is not know
% * Problem: the algorithm is parametric
% * Solution: set |p = 50| so that |t| is the median of the distribution of pixel values
%
% *Reference*
%
% * W. Doyle, Operation useful for similarity-invariant pattern recognition,
% J. Assoc. Comput. Mach, vol. 9, pp. 259-267, 1962
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%
%% MINERROR algorithm
% 
% * Similar to the OTSU algorithm
% * Views the histogram as an estimate of the probability density function of the mixture
% population (objects and background)
% * Assumes a Gaussian mixture model, that is, *A)* the pixels in the two categories come from a
% normal distribution and *B)* the normal distributions may have different means as well as variances
% * Define the following statistics:
%
% $p_{t} = \frac{A_{t}}{A_{n}}, q_{t} = \frac{A_{n} - A_{f}}{A_{n}}$
% 
% $\sigma{_{t}}^{2} = \frac{C_{t}}{A_{t}} - \mu{_{t}}^2, \tau{_{t}^{2}} = \frac{C_{n} - C_{t}}{A_{n} - A_{t}} - \nu{_{t}^2}$
%
% * Set |t| to the value of |j| at which
%   $p_{j}\textup{log}\begin{pmatrix}\sigma_{j}\\p_{j}\end{pmatrix} + q_{j}\textup{log}\begin{pmatrix}\tau_{j}\\q_{i}\end{pmatrix}$  is minumized
%
% *Reference*
%
% * J. Kittler and J. Illingworth, Minimum error thresholding, Pattern
% Recognition, vol. 19, pp. 41-47, 1986
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%
%% MINERROR ITER algorithm
% 
% * The iterative version of the MINERROR algorithm is computationally less intensive
% * Find initial value for |t| using MEAN
% * The integer part of the larger solution provides a new value |t|:
%
% $x^{2}(\frac{1}{\sigma^{2}} - \frac{1}{\tau^{2}}) - 2x(\frac{\mu}{\sigma^{2}} + \frac{\nu}{\tau^{2}}) + (\frac{\mu^{2}}{\sigma^{2}} - \frac{\nu^{2}}{\tau^{2}} + \textup{log}(\frac{\sigma^{2}q^{2}}{\tau^{2}p^{2}})) = 0$
% 
% * Let w0, w1 and w2 denote the three terms
% * Set $t = \frac{w_{1} + \sqrt{ {w_{1}}^{2} - w_{0}w_{2}}}{w_{0}}$
% * Recalculate all the terms using the new value of |t| and re-derive |t|
% * Repeat until convergence
% * This minimizes the number of misclassi?cations between the two normal
% distributions with the given means, variances, and proportions
% * The algorithm fails to converge if the quadratic equation does not have a real solution
%
% *Reference*
%
% * J. Kittler and J. Illingworth, Minimum error thresholding, Pattern
% Recognition, vol. 19, pp. 41-47, 1986
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%
%% MINIMUM algorithm
% 
% * Assumes a bimodal histogram
% * The histogram needs to be smoothed (using the three-point mean filter) iteratively until the
% histogram has only two local maxima
% * Choose |t| such that |yt - 1 > yt ? yt + 1|
% * Unsuitable for images that have a histogram with extremely unequal peaks or a broad and flat valley
%
% *Reference*
%
% * J. M. S. Prewitt and M. L. Mendelsohn, The analysis of cell images, in
% Ann. New York Acad. Sci., vol. 128, pp. 1035-1053, 1966
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%
%% MOMENTS algorithm
% 
% * Choose |t| such that the binary image has the same ?rst three moments as the gray-level image
% * his is achieved by setting |t| such that |At/An| is the value of the fraction nearest to |x0|, where
%
% $x_{0} = \frac{1}{2} - \frac{B_{n}/A_{n} + x_{2}/2}{\sqrt{x_{2}^{2} - 4x_{1}}}, x_1 = \frac{B_{n}D_{n} - C_{n}^{2}}{A_{n}C_{n} - B_{n}2'}$
%
% $x_{2} = \frac{B_{n}C_{n} - A_{n}D_{n}}{A_{n}C_{n} - B_{n}^{2}}, D_{n} = \sum_{i=0}^{n}i^{2}y_{i}$ 
%
%
% *Reference*
%
% * W. Tsai, Moment-preserving thresholding: a new approach, Comput.
% Vision Graphics Image Process., vol. 29, pp. 377-393, 1985
%
% *Acknowledgements* 
% Based on the <https://github.com/carandraug/histthresh HistThresh Toolbox> by Antti Niemist&ouml;, Tampere University of Technology, Finland
%
%
%% OTSU algorithm
% 
% * Matlab implementation of the Otsu algorithm
% * The |t| value is calculated using |graythresh|
%
% *Reference*
%
% * Otsu, N., "A Threshold Selection Method from Gray-Level Histograms," IEEE Transactions on Systems, Man, and Cybernetics, Vol. 9, No. 1, 1979, pp. 62-66.
%
%
%% Programming tips
% This function is compatible with the batch scripting.
% 
% * Define parameters as a structure, where the names of the fields can be
% checked from the tooltips of the widgets
% * Some of the parameters are optional
% * use mibController.startController function, where the 3rd input is the
% defined structure with parameters
%
%
% For example,
% 
%   BatchOpt.colChannel = 2;    % define color channel for thresholding 
%   BatchOpt.Mode = '3D, Stack';     % mode to use 
%   BatchOpt.Method = 'Otsu';       % thresholding algorithm 
%   BatchOpt.Destination = 'selection';       % [optional] destination layer, 'mask' or 'selection'
%   BatchOpt.t = [1 1];     % [optional] time points, [t1, t2] 
%   BatchOpt.z = [10 20];    % [optional] slices, [z1, z2] 
%   BatchOpt.x = [10 120];    % [optional] part of the image, [z1, z2] 
%   BatchOpt.Orientation = 4;      % [optional], dataset orientation
%   obj.startController('mibHistThresController', [], BatchOpt);  % start the thresholding
%
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu.html *Menu*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu_tools.html *Tools*>
##### SOURCE END #####
--></body></html>