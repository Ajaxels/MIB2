
<!DOCTYPE html>
<html lang="en"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Mask Generators panel</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-06-17"><meta name="DC.source" content="ug_panel_mask_generators.m"><style>
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:160%; padding: 20px; }

pre { font-size:12px; }
code { font-size: 1.15em; }
pre { margin:0px 0px 15px; overflow-x:auto; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 15px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }




.kbd {   font-family: monospace; 	border: 1px solid #aaa; 	-moz-border-radius: 0.2em; 	-webkit-border-radius: 0.2em; 	border-radius: 0.2em; 	-moz-box-shadow: 0.1em 0.2em 0.2em #ddd; 	-webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; 	box-shadow: 0.1em 0.2em 0.2em #ddd; 	background-color: #f9f9f9; 	background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); 	background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); 	background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); 	background-image: linear-gradient([[:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); 	padding: 0.1em 0.4em; 	font-family: inherit; 	font-size: 1em; }
.h3 { color: #E65100; font-size: 12px; font-weight: bold; }
.code { font-family: monospace; font-size: 10pt; background: #eee; padding: 1pt 3pt; }

#tooltiptext {
  visibility: hidden;
  padding: 5px 10px;
  font-size: 75%;
  line-height:110%;
  text-align: center;
  background-color: black;
  color: #ddd;
  border-radius: 6px;
  position: fixed;
  bottom: 11px;
  right: 62px;
  z-index: 2;
}
#tooltiptext::after {
  content: " ";
  position: absolute;
  top: 50%;
  left: 100%;
  margin-top: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent transparent black;
}
.tooltip:hover #tooltiptext {
  visibility: visible;
}
#return-link {
    position: fixed;
    bottom: 10px;
    right: 10px;
    overflow: visible;
    font-size:120%;
    background: rgba(0, 0, 0, 0.75);
    border-style: solid;
    border-width: 3pt;
    border-color: #202020;
    border-radius: 4px;
    cursor: pointer;
    }
#return-link > p { padding:3px; margin:0; color:#C0C0C0;}
.MATLAB-Help {
width: 100%;
margin-bottom: 12px;
border: 1px solid #ccc;
border-right: none;
border-bottom: none;
font-size: 96%;
line-height: 1.4;
table-layout: fixed;
overflow:hidden;}

.MATLAB-Help > thead > tr > th {
padding: 6px 5px;
border: none;
border-right: 1px solid #ccc;
border-bottom: 1px solid #ccc;
background: #F2F2F2;
color: #000;
font-weight: bold;
text-align: left;
vertical-align: middle;}

.MATLAB-Help td{padding: 5px 5px;
border: none;
border-right: 1px solid #ccc;
border-bottom: 1px solid #ccc;
vertical-align: middle;}

.language-matlab { line-height:135% }

.collapse-link {float:right; line-height:200%; padding-left:10px; margin:0}


details > summary,
.details-div {
  padding: 8px 20px;
  border-style: solid;
  border-width: 1.2pt;
  border-color: #E0E0E0;
}
details > summary {
  border-radius:6px 6px 0 0;
  background-color: #F2F2F2;
  cursor: pointer;
}
.details-div {
  border-top-style: none;
  border-radius: 0 0 6px 6px;
}
.image-fit-svg,
.image-fit {
    max-width:  95%;
    max-height: 100%;
    margin:     auto;
}
.image-fit-svg{ padding:0px; max-width:500px; }
details > img.image-fit-svg{ padding: 0px 0px 10px; }
@media (max-width: 580px) {
  .image-fit-svg { max-width: 95%; }
}
.pretty-link  { color:#001188 !important; }
</style>
<style id="dark-theme">
    h2, h3       { color: #B0B0B0; }
    html body    { background-color: #101010; color: #B0B0B0; }
    .pretty-link { color: #C46313 !important; }
    a, a:visited { color: #C46313 }
    a:hover      { color: orange; }
    details > summary,
    .details-div      { border-color:     #505050; }
    details > summary { background-color: #202020; }
    pre.codeinput     { border-width: 1.2pt; border-color:#001B33; background:#001129; color:#F0F0F0; }
    pre.codeoutput    { color:#A5A5A5; }
    span.keyword      { color:#FF9D00; }
    span.comment      { color:#808080; }
    span.string       { color:#3AD900; }
    span.untermstring { color:#FFEE80; }
    span.syscmd       { color:#CCCCCC; }
    .MATLAB-Help, .MATLAB-Help > thead > tr > th, .MATLAB-Help td { border-color:#505050; }
    .MATLAB-Help > thead > tr > th { background: #202020; color: #B0B0B0; }
    .summary-sub-heading { color:#909090; }
    .show-if-light    { display:none }
</style>
<style id="hide-dark">
     .show-if-dark { display:none }
</style>

<style id="anchor-offsets">
    h2::before, a[id]::before{
    content: "";
    display: block;
    height: 100px;
    margin: -100px 0 0;
    visibility: hidden;
    width:10%;
    z-index: -1;
}
</style>

<script>
          var returnElem = null;
          var skipCheck  = false;

          function hide_back_link()
          {
              returnButton.style.display = "none";
              try{
                 window.removeEventListener("scroll", update_back_position, true);
                 window.removeEventListener("resize", update_back_position, true);
                 parent.window.removeEventListener("scroll", update_back_position, true);
                 parent.window.removeEventListener("resize", update_back_position, true);}
              catch(e){}
          }

          function get_offset(element)
          {
              if (!element.getClientRects().length){ return { top: 0, left: 0 }; }
              var rect = element.getBoundingClientRect();
              var win  = element.ownerDocument.defaultView;
              return ( {top:  rect.top  + win.pageYOffset,
                        left: rect.left + win.pageXOffset} );
          }

          function jump_to()
          {
              var clickedElem = event.target;
              var clickedID   = clickedElem.closest("span");
              if (clickedID){
                clickedID = clickedID.getAttribute("id");
                if (clickedID.localeCompare("jump-close")===0) { return };}
              clickedID = clickedElem.closest("div").getAttribute("id");
              if (clickedID && clickedID.localeCompare("return-link")===0)
              {
                  if (returnElem)
                  {
                      event.preventDefault();
                      hide_back_link();
                      returnElem.scrollIntoView();
                      if (contentDiv.getAttribute("data-isHelpBrowser")){
                         contentDiv.scrollTop = contentDiv.scrollTop-100; }
                      if (contentDiv.getAttribute("data-isMATLABCentral")){
                         parent.window.scrollBy(0,-100)}
                      returnElem = null;
                  }
              }
              else
              {
                  var href = clickedElem.closest("a").getAttribute("href");
                  if ( href && href[0] == "#" )
                  {
                     var target = document.getElementById(href.substring(1));
                     var enclosingBox = target;
                     while ( enclosingBox )
                     {
                        prevBox      = enclosingBox;
                        enclosingBox = enclosingBox.closest("details");
                        if ( enclosingBox===prevBox ){
                           enclosingBox = enclosingBox.parentElement
                           if ( enclosingBox ) { enclosingBox = enclosingBox.closest("details"); }  }
                        if (enclosingBox && !enclosingBox.open) { open_details(enclosingBox.id) }
                     }
                     if (target && in_iFrame() && !contentDiv.getAttribute("data-isHelpBrowser") ){
                        event.preventDefault();
                        target.scrollIntoView(); }
                     var nextElem = target.nextElementSibling;
                     var nextNode = target.nextSibling;
                     while ( nextNode && nextNode.nodeType==Node.TEXT_NODE && nextNode.data.trim().length == 0 ){
                        nextNode = nextNode.nextSibling;}
                     if ( nextElem && nextElem===nextNode && nextElem.localName.localeCompare("details")===0 && !nextElem.open){
                        open_details(nextElem.id);}
                  }
                  else { return }
                  if (!contentDiv.getAttribute("data-isHelpBrowser"))
                  {
                      update_back_position();
                      returnButton.style.display = "block";
                      var linkTop   = clickedElem.offsetTop;
                      var targetTop = target.offsetTop;
                      if (targetTop>linkTop){
                          document.getElementById("down").style.display = "none";
                          document.getElementById("up").style.display   = "inline"; }
                      else{
                          document.getElementById("up").style.display   = "none";
                          document.getElementById("down").style.display = "inline"; }
                      returnElem = clickedElem;
                  }
              }
          }

          function open_details(detailsID)
          {
              var details  = document.getElementById(detailsID);
              skipCheck    = true;
              state_check(details.id);
              details.open = true;
          }

          function update_back_position()
          {
              try
              {
                  window.addEventListener("scroll", update_back_position, true);
                  window.addEventListener("resize", update_back_position, true);
                  var scrollPos;
                  if (in_iFrame())
                  {
                      parent.window.addEventListener("scroll", update_back_position, true);
                      parent.window.addEventListener("resize", update_back_position, true);
                      var iFrame         = window.frameElement;
                      var frameOffset    = get_offset(iFrame);
                      var documentBottom = parent.window.innerHeight  + parent.window.scrollY;
                      var extHeight      = Math.round(frameOffset.top + iFrame.getBoundingClientRect().height - documentBottom);
                      if (extHeight<0) { extHeight = 0; }
                      returnButton.style.bottom = (10+extHeight) + "px";
                      document.getElementById("tooltiptext").style.bottom = (11+extHeight) + "px";
                      scrollPos = contentDiv.scrollTop - 25 + iFrame.getBoundingClientRect().height - extHeight;
                  }
                  else{
                      scrollPos = window.scrollY + window.innerHeight - 25;}
                  if (returnElem.offsetTop>scrollPos){
                      document.getElementById("down").style.display = "inline";
                      document.getElementById("up").style.display   = "none";   }
                  else{
                      document.getElementById("down").style.display = "none";
                      document.getElementById("up").style.display   = "inline"; }
              }
              catch(e){}
          }
          function set_theme(themePref)
          {
            var themeSwitch     = document.getElementById("ToggleTheme");
            var themeSwitchText = "switch to";
            var switchToText    = null;
            if (!themePref){ themePref = get_theme_pref(); }
            if (themePref.localeCompare("light")===0){
                document.getElementById("dark-theme").sheet.disabled = true;
                document.getElementById("hide-dark").sheet.disabled  = false;
                switchToText = " dark theme";}
            else{
                document.getElementById("dark-theme").sheet.disabled = false;
                document.getElementById("hide-dark").sheet.disabled  = true;
                switchToText = " light theme";}
            themeSwitch.innerHTML = themeSwitchText + switchToText;
            set_theme_pref(themePref);
          }

          function toggle_theme()
          {
            if (document.getElementById("dark-theme").sheet.disabled) { set_theme("dark");  }
            else                                                      { set_theme("light"); }
          }

          function set_theme_pref(themePref)
          {
              var d = new Date();
              d.setTime(d.getTime() + (2*365*24*60*60*1000));
              var expires = "expires="+ d.toUTCString();
              document.cookie = "themepref=" + themePref + ";" + expires + "path=/";
              localStorage.setItem("PRETTY_THEME", themePref);
          }

          function get_theme_pref() {
              var name = "themepref=";
              var decodedCookie = decodeURIComponent(document.cookie);
              var ca = decodedCookie.split(';');
              for(var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                  c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                  return c.substring(name.length, c.length);
                }
              }
              var docTheme = localStorage.getItem("PRETTY_THEME");
              if (docTheme) { return docTheme }
              else          { return "light"  }
          }

          function toggle_details(section)
          {
            var link;
            var subSection;
            var details;
            var linkText;
            var i;
            var openState  = true;
            var border     = "6px 6px 0 0;"
            if (section===0)
            {
              link = document.getElementById("Toggle"+section.toString());
              if (link.innerHTML.localeCompare("collapse all on page")===0){
                  openState = false;
                  border    = "6px;"
                  linkText  = "expand all";}
              else{
                  linkText   = "collapse all";}
              link.innerHTML = linkText + " on page";
              for (i = 0; i < allDetails.length; i++){
                 allDetails[i].open = openState;
                 allDetails[i].children[0].setAttribute( 'style', "border-radius:"+border );
                 link = document.getElementById("Toggle"+allDetails[i].id.split(".", 1));
                 if (allDetails[i].id.charAt(0).localeCompare("0") && link){link.innerHTML = linkText;}}
            }
            else
            {
               link = document.getElementById("Toggle"+section.toString());
               subSection = 1;
               if (link.innerHTML.localeCompare("collapse all")===0){
                  openState      = false;
                  border         = "6px;"
                  link.innerHTML = "expand all";}
               else{
                  link.innerHTML = "collapse all";}
               details = document.getElementById(section.toString()+"."+subSection.toString());
               while (details){
                    details.open = openState;
                    details.children[0].setAttribute( 'style', "border-radius:"+border );
                    subSection++;
                    details = document.getElementById(section.toString()+"."+subSection.toString());}
               var allCollapsed = true;
               var allExpanded  = true;
               for (i = 0; i < allDetails.length; i++){
                   check_if_open(allDetails[i]);}
               link = document.getElementById("Toggle0");
               if (allExpanded) {link.innerHTML = "collapse all on page";}
               if (allCollapsed){link.innerHTML = "expand all on page";}
            }
            function check_if_open(details)
            {
                if (details.open){allCollapsed = false;}
                else             {allExpanded  = false;}
            }
          }

          function state_check(detailsID)
          {
              // first deal with just the section
              if (event.detail){document.activeElement.blur();}
              var clickedElem   = event.target;
              if (!skipCheck && clickedElem.localName.localeCompare("summary"))
              { 
                if (!(clickedElem.closest("summary"))) { return };
              };
              var details       = document.getElementById(detailsID);
              if ( !skipCheck ) {
                  var parentID  = clickedElem.closest("details").id;
                  if (details.id.localeCompare(parentID)) { return };}
              skipCheck         = false;
              var clickedStatus = details.open;
              var section       = detailsID.split(".", 1);
              var subSection    = 1;
              var allCollapsed  = true;
              var allExpanded   = true;
              var link          = document.getElementById("Toggle"+section);
              if (clickedStatus) { details.children[0].setAttribute( 'style', "border-radius:6px;" ); }
              else               { details.children[0].setAttribute( 'style', "border-radius:6px 6px 0 0;" ); }
              if (link)
              {
                  details = document.getElementById(section+"."+subSection.toString());
                  while (details){
                    check_if_open(details);
                    subSection++;
                    details = document.getElementById(section+"."+subSection.toString());}
                  if (allExpanded) {link.innerHTML = "collapse all";}
                  if (allCollapsed){link.innerHTML = "expand all";}
              }
              // then the whole page
              allCollapsed   = true;
              allExpanded    = true;
              for (var i = 0; i < allDetails.length; i++){
                  check_if_open(allDetails[i]);}
              link = document.getElementById("Toggle0");
              if (allExpanded) {link.innerHTML = "collapse all on page";}
              if (allCollapsed){link.innerHTML = "expand all on page";}

              function check_if_open(details)
              {
                  var openStatus
                  if (detailsID.localeCompare( details.id )===0 ){openStatus = !clickedStatus;}
                  else                                           {openStatus = details.open;}
                  if (openStatus){allCollapsed = false;}
                  else           {allExpanded  = false;}
              }
          }

          function in_iFrame ()
          {
               try {
                   return window.self !== window.top;
               } catch (e) {
                   return true;
               }
          }
</script>
</head><body>
<div class="content">
<div id="return-link" style="display:none;" class="tooltip">
<p onclick="jump_to()">
    <span onclick="jump_to()"><span id="up">&#8679;</span><span id="down">&#8681;</span>
    <span onclick="hide_back_link()" style="padding:2px; font-size:120%;" id="jump-close"><b onclick="hide_back_link()">&times;</b></span></span>
</p>
<div id="tooltiptext">click to return
<br>(click <b>&times;</b> to hide)</div>
</div><script>document.getElementById("dark-theme").sheet.disabled = true;</script><h1>Mask Generators panel</h1><!--introduction-->
<p>This panel hosts several ways of automatic mask generation. Specific areas of interest from the generated mask may further be selected for segmentation. <a href="ug_gui_data_layers.html">See more about masks</a>.</p>
<p><b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <code><b>--&gt;</b></code> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_panels.html"><b>Panels</b></a></p><!--/introduction-->
<p style="margin:0px; line-height:0;">&nbsp;</p>
<p onclick="toggle_details(0)" class="collapse-link"><a href="javascript:void(0);" id="Toggle0">collapse all on page</a></p><h2>Contents</h2>
<div><ul><li><a href="#1">Common fields</a></li>
<li><a href="#2">Frangi Filter</a></li>
<li><a href="#3">Morphological filters</a></li>
<li><a href="#6">Strel Filter</a></li></ul></div><h2 id="1">Common fields</h2>
<p>There are several common fields that do not depend on type of the selected mask generator.</p>
<p><img class="image-fit" src="images\PanelsMaskGeneratorCommon.jpg" alt=""> </p>
<div><ul><li>1. The <b>Filter type</b> combo box, allows to select one of the possible mask generators</li>
<li>2. The <b>Mode</b> radio buttons:</li></ul></div>
<ul style="position:relative; left:35px;">
<li><b>current</b>, generate mask for the currently shown slice;</li>
<li><b>2D all</b>, generate mask for the whole dataset using the 2D mode,
<em>i.e.</em> slice by slice;</li>
<li><b>3D</b>, generate mask for the whole dataset using the 3D mode;</li>
</ul>
<p>the whole dataset in the 2D mode, <i>i.e.</i> slice by slice; <i>3D</i> use the 3D mode for the mask generation</p>
<p>3. <b>Do it</b> button:</p>
<ul style="position:relative; left:35px;">
<li>
-<b>left mouse click</b>, starts the selected generator. The existing mask will be deleted.
</li>
<li>
-<b>right mouse click + Do new mask</b>, starts the selected generator.
The existing mask will be deleted.
<br>
<img class="image-fit" src="images\PanelsMaskGeneratorDropdown.png">
</li>
<li>
-<b>right mouse click + Generate new mask and add it to the existing mask</b>, the generated mask will be added to the existing mask.
This option may be
used for multi-dimensional filtering: 1. run Generator for XY; 2. Change
dimension by pressing |'XZ'| or |'YZ'| button in the Toolbar; 3. Run Generator again with the |Generate new mask and add it to the existing mask| option.
</li>
</ul>
<p style="margin:0px; line-height:0;">&nbsp;</p>
<p onclick="toggle_details(1)" class="collapse-link"><a href="javascript:void(0);" id="Toggle1">collapse all</a></p><h2 id="2">Frangi Filter</h2>
<p><a href="http://www.mathworks.com/matlabcentral/fileexchange/24409-hessian-based-frangi-vesselness-filter">Hessian based Frangi Vesselness filter</a>, written by Marc Schrijver and Dirk-Jan Kroon. This function uses the eigenvectors of the Hessian to compute the likeliness of an image region to contain vessels or other image ridges, according to the method described by Frangi <a href="http://www.dtic.upf.edu/~afrangi/articles/miccai1998.pdf">1998</a>, <a href="http://www.tecn.upf.es/~afrangi/articles/tmi2001.pdf">2001</a>.</p>
<p><b>Note</b>, to work properly this function should be compiled. See details in <a href="im_browser_system_requirements.html">System Requirements</a></p>
<p><img class="image-fit" src="images\PanelsMaskGeneratorFrangi.png" alt=""> </p>
<details open onclick="state_check('1.1')" id="1.1"><summary> <b>Parameters:</b> </summary>
<div class="details-div">
<p></p>
<div><ul style="margin-bottom:0px;"><li><b>Range</b>, the range of sigmas used, default [1-6]</li>
<li><b>Ratio</b>, step size between sigmas, default [2]</li>
<li><b>beta1</b>, the Frangi correction constant, default [0.9]</li>
<li><b>beta2</b>, the Frangi correction constant, default [15]</li>
<li><b>beta3</b>, the Frangi vesselness constant which gives the threshold between eigenvalues of noise and vessel structure. A thumb rule is dividing the the greyvalues of the vessels by 4 till 6, default [500];</li>
<li><b>B/W threshold</b>, defines thresholding parameter for generation of the <code>Mask</code> layer. When set to 0 results in the filtered instead of binary image.</li>
<li><b>Object size limit</b>, after the run of the Frangi filter removes all 2D objects that are smaller than this value.</li>
<li><span class="kbd">[&#10003;] <b>Black on white</b></span> checkbox, if checked, detects black ridges on white background.</li></ul></div>
</div>
</details>
<br><h2 id="3">Morphological filters</h2>
<p>Set of MATLAB based morphological filters.</p>
<p><img class="image-fit" src="images\PanelsMaskGeneratorMorphFilters.png" alt=""> </p>
<div><ul><li><b>Extended-maxima transform</b> - based on <code>imextendedmax</code> function of MATLAB. Computes the extended-maxima transform, which is the regional maxima of the H-maxima transform. Regional maxima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a lower value.</li></ul></div>
<p><img class="image-fit" src="images\PanelsMaskGeneratorMorphFiltersExtMaxTrans.jpg" alt=""> </p>
<div><ul><li><b>Extended-minima transform</b> - based on <code>imextendedmin</code> function of MATLAB. Computes the extended-minima transform, which is the regional minima of the H-minima transform. Regional minima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a higher value.</li></ul></div>
<p><img class="image-fit" src="images\PanelsMaskGeneratorMorphFiltersExtMinTrans.jpg" alt=""> </p>
<div><ul><li><b>H-maxima transform</b> - suppresses all maxima in the intensity image whose height is less than H-value. Regional maxima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a lower value. The resulting image is then thresholded using the provided <code>Threshold</code> value.</li></ul></div>
<p><img class="image-fit" src="images\PanelsMaskGeneratorMorphFiltersHMaxTrans.jpg" alt=""> </p>
<div><ul><li><b>H-minima transform</b> - suppresses all minima in the grayscale image whose depth is less than H-value. Regional minima are connected components of pixels with a constant intensity value (t) whose external boundary pixels all have a value greater than t. The resulting image is then thresholded using the provided <code>Threshold</code> value.</li></ul></div>
<div><ul><li><b>Regional maxima</b> - based on <code>imregionalmax</code> function of MATLAB. Returns the binary mask that identifies the locations of the regional maxima in the image. In mask, pixels that are set to 1 identify regional maxima; all other pixels are set to 0. Regional maxima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a lower value.</li></ul></div>
<div><ul><li><b>Regional minima</b> - based on <code>imregionalmin</code> function of MATLAB. The output binary mask has value 1 corresponding to the pixels of the image that belong to regional minima and 0 otherwise. Regional minima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a higher value.</li></ul></div><h2 id="6">Strel Filter</h2>
<p>Generate mask based on morphological image opening and black-and-white thresholding. The function first performs morphological bottom-hat (<code>Black on white</code> is checked) or top-hat (<code>Black on white</code> is unchecked) filtering of the image. The top-hat filtering computes the morphological opening of the image (using <code>imopen</code>) and then subtracts the result from the original image. The result is then black and white thresholded with parameter in the <code>B/W threshold</code> edit box.</p>
<p><img class="image-fit" src="images\PanelsMaskGeneratorStrel.png" alt=""> </p>
<div><ol><li><b>Strel size</b>, defines size of the structural element (<code>disk</code> type) for <code>imtophat</code> and <code>imbothat</code> filtering.</li>
<li>The <span class="kbd">[&#10003;] <b>Fill</b></span> checkbox, check it to fill holes in the resulted <code>Mask</code> image.</li>
<li><b>B/W threshold</b>, specifies parameter for the black and white thresholding.</li>
<li><b>Size limit</b>, limits the size of generated 2D objects so that objects smaller than this value are removed from the <code>Mask</code> during the filter run.</li>
<li>The <span class="kbd">[&#10003;] <b>Black on white</b></span> checkbox, when checked, the filter will use morphological bottom-hat filtering (<code>imbothat</code>). When unchecked - morphological top-hat filtering (<code>imtophat</code>).</li></ol></div>
<p><b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <code><b>--&gt;</b></code> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_panels.html"><b>Panels</b></a></p>
<p></p>
<p>
<script>
  var allDetails = document.getElementsByTagName('details');
  toggle_details(0);
</script>
</p>
<p class="footer"><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a> and subsequently processed by <a class="pretty-link" href="https://www.mathworks.com/matlabcentral/fileexchange/78059-prettify-matlab-html">prettify_MATLAB_html</a> V6.5</p>
<p id="iFrameBuf">&nbsp;</p></div><!--
##### SOURCE BEGIN #####
%% Mask Generators panel
% This panel hosts several ways of automatic mask generation. Specific areas of interest from the generated mask may 
% further be selected for segmentation. <ug_gui_data_layers.html See more about masks>.
%
%
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_panels.html *Panels*>
%% Common fields
% There are several common fields that do not depend on type of the selected mask
% generator.
%
% <<images\PanelsMaskGeneratorCommon.jpg>>
% 
% * 1. The *Filter type* combo box, allows to select one of the possible mask
% generators
% * 2. The *Mode* radio buttons:
%
%
% <html lang="en">
% <ul style="position:relative; left:35px;">
% <li><b>current</b>, generate mask for the currently shown slice;</li>
% <li><b>2D all</b>, generate mask for the whole dataset using the 2D mode,
% <em>i.e.</em> slice by slice;</li>
% <li><b>3D</b>, generate mask for the whole dataset using the 3D mode;</li>
% </ul>
% </html>
%
% the whole dataset in the 2D mode, _i.e._ slice by slice; _3D_ use the 3D mode for the mask generation
%
% 3. *Do it* button:
%
%
% <html lang="en">
% <ul style="position:relative; left:35px;">
% <li> 
% -<b>left mouse click</b>, starts the selected generator. The existing mask will be deleted.
% </li>
% <li> 
% -<b>right mouse click + Do new mask</b>, starts the selected generator.
% The existing mask will be deleted.
<br>
% <img src="images\PanelsMaskGeneratorDropdown.png">
% </li>
% <li> 
% -<b>right mouse click + Generate new mask and add it to the existing mask</b>, the generated mask will be added to the existing mask.
% This option may be
% used for multi-dimensional filtering: 1. run Generator for XY; 2. Change
% dimension by pressing |'XZ'| or |'YZ'| button in the Toolbar; 3. Run Generator again with the |Generate new mask and add it to the existing mask| option.
% </li>
% </ul>
% </html>
%
%
%% Frangi Filter
% <http://www.mathworks.com/matlabcentral/fileexchange/24409-hessian-based-frangi-vesselness-filter
% Hessian based Frangi Vesselness filter>, written by Marc Schrijver and Dirk-Jan Kroon. This 
% function uses the eigenvectors of the Hessian to compute the likeliness 
% of an image region to contain vessels or other image ridges, 
% according to the method described by Frangi <http://www.dtic.upf.edu/~afrangi/articles/miccai1998.pdf 1998>, <http://www.tecn.upf.es/~afrangi/articles/tmi2001.pdf 2001>.
%
% *Note*, to work properly this function should be compiled. See details in
% <im_browser_system_requirements.html System Requirements>
% 
% <<images\PanelsMaskGeneratorFrangi.png>>
%
% [dtls]<summary> *Parameters:* </summary>
<div class="details-div">
%
% * *Range*, the range of sigmas used, default [1-6]
% * *Ratio*, step size between sigmas, default [2]
% * *beta1*, the Frangi correction constant, default [0.9]
% * *beta2*, the Frangi correction constant, default [15]
% * *beta3*, the Frangi vesselness constant which gives the threshold between eigenvalues of noise and vessel structure. A thumb rule is dividing the the greyvalues of the vessels by 4 till 6, default [500];
% * *B/W threshold*, defines thresholding parameter for generation of the
% |Mask| layer. When set to 0 results in the filtered instead of binary
% image.
% * *Object size limit*, after the run of the Frangi filter removes all
% 2D objects that are smaller than this value.
% * [class.kbd][&#10003;] *Black on white*[/class] checkbox, if checked, detects black ridges on white background.
%
% [/dtls]
%
%% Morphological filters
% Set of MATLAB based morphological filters.
% 
% <<images\PanelsMaskGeneratorMorphFilters.png>>
%
% * *Extended-maxima transform* - based on |imextendedmax| function of
% MATLAB. Computes the extended-maxima transform, which is the regional maxima of the H-maxima transform. 
% Regional maxima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a lower value.
%%
% 
% <<images\PanelsMaskGeneratorMorphFiltersExtMaxTrans.jpg>>
% 
%
% * *Extended-minima transform* - based on |imextendedmin| function of
% MATLAB. Computes the extended-minima transform, which is the regional minima of the H-minima transform. Regional minima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a higher value.
%%
% 
% <<images\PanelsMaskGeneratorMorphFiltersExtMinTrans.jpg>>
% 
% * *H-maxima transform* - suppresses all maxima in the intensity image whose height is less than H-value. 
% Regional maxima are connected components of pixels with a constant intensity value, and whose external 
% boundary pixels all have a lower value. The resulting image is then
% thresholded using the provided |Threshold| value.
% 
% <<images\PanelsMaskGeneratorMorphFiltersHMaxTrans.jpg>>
%
% * *H-minima transform* - suppresses all minima in the grayscale image whose depth is less than H-value. 
% Regional minima are connected components of pixels with a constant intensity value (t) whose external boundary pixels all have a value greater than t. 
% The resulting image is then thresholded using the provided |Threshold| value.
%
% * *Regional maxima* - based on |imregionalmax| function of MATLAB. Returns the binary mask that identifies the locations of the regional 
% maxima in the image. In mask, pixels that are set to 1 identify regional
% maxima; all other pixels are set to 0. Regional maxima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a lower value.
%
% * *Regional minima* - based on |imregionalmin| function of MATLAB. The output binary mask has value 1 corresponding to the pixels of the image
% that belong to regional minima and 0 otherwise. Regional minima are connected components of pixels with a constant intensity value, and whose external boundary pixels all have a higher value. 
%
%
%% Strel Filter
% Generate mask based on morphological image opening and black-and-white
% thresholding. The function first performs morphological bottom-hat (|Black on white| is checked)
% or top-hat (|Black on white| is unchecked) filtering of the image. 
% The top-hat filtering computes the morphological opening of the image (using |imopen|)
% and then subtracts the result from the original image. The result is then
% black and white thresholded with parameter in the |B/W threshold| edit
% box.
%
% <<images\PanelsMaskGeneratorStrel.png>>
%
% # *Strel size*, defines size of the structural element (|disk| type) for |imtophat| and |imbothat|
% filtering. 
% # The [class.kbd][&#10003;] *Fill*[/class] checkbox, check it to fill holes in the resulted |Mask| image.
% # *B/W threshold*, specifies parameter for the black and white thresholding.
% # *Size limit*, limits the size of generated 2D objects so that objects smaller than this value are removed from the |Mask| during the
% filter run.
% # The [class.kbd][&#10003;] *Black on white*[/class] checkbox, when checked, the filter will use morphological bottom-hat filtering
% (|imbothat|). When unchecked - morphological top-hat filtering (|imtophat|).
%
%
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_panels.html *Panels*>
%%
% [cssClasses]
% .kbd { 
%   font-family: monospace;
% 	border: 1px solid #aaa; 
% 	-moz-border-radius: 0.2em; 
% 	-webkit-border-radius: 0.2em; 
% 	border-radius: 0.2em; 
% 	-moz-box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	-webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	background-color: #f9f9f9; 
% 	background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: linear-gradient(&#91;&#91;:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); 
% 	padding: 0.1em 0.4em; 
% 	font-family: inherit; 
% 	font-size: 1em;
% }
% .h3 {
% color: #E65100;
% font-size: 12px;
% font-weight: bold;
% }
% .code {
% font-family: monospace;
% font-size: 10pt;
% background: #eee;
% padding: 1pt 3pt;
% }
% [/cssClasses]
%%
% <html lang="en">
% <script>
%   var allDetails = document.getElementsByTagName('details');
%   toggle_details(0);
% </script>
% </html>
##### SOURCE END #####
--><script>
var allDetails   = document.getElementsByTagName('details');
var contentDiv   = document.getElementsByClassName("content"); contentDiv = contentDiv[0];
var returnButton = document.getElementById("return-link");
document.getElementById("iFrameBuf").style.display = "none";
if(in_iFrame())
{
   try{
      var footerNav = parent.document.getElementsByClassName("footernav");
      var tabPane   = parent.document.getElementsByClassName("tab-pane");}
   catch(err) { var footerNav = []; var tabPane = [];};
   if(!(footerNav.length) || tabPane.length)
   {
      contentDiv.style.overflowY = "scroll";
      contentDiv.style.overflowX = "hidden";
      contentDiv.style.position  = "absolute";
      contentDiv.style.width     = "95%";
      contentDiv.style.top       = 0;
      contentDiv.style.bottom    = 0;
      if (tabPane.length){
         contentDiv.setAttribute("data-isMATLABCentral","1");
         returnButton.style.right = "40px";
         document.getElementById("tooltiptext").style.right = "92px"; }
      document.getElementById("iFrameBuf").style.display = "block";
   }
   else { contentDiv.setAttribute("data-isHelpBrowser","1"); }
}
if (!contentDiv.getAttribute("data-isHelpBrowser") && !contentDiv.getAttribute("data-isMATLABCentral") ){
   document.getElementById("anchor-offsets").sheet.disabled = true; }
var jumpLinks = document.getElementsByTagName("a");
for (var i = 0; i < jumpLinks.length; i++){
  href = jumpLinks[i].getAttribute("href");
  if (href && href[0] == "#") { jumpLinks[i].onclick = jump_to;}}
</script></body></html>