<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Alignment and Drift Correction</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-15">
<meta name="DC.source" content="ug_gui_menu_dataset_alignment.m">
<style>
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,my-a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a,my-a { color:#005fce; text-decoration:none; }
my-a:hover { cursor: pointer; }
a:hover,my-a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:160%; padding: 20px; }

pre { font-size:12px; }
code { font-size: 1.15em; }
pre { margin:0px 0px 15px; overflow-x:auto; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 15px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }




.kbd { font-family: monospace; border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.2em 0.2em #ddd; -webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; box-shadow: 0.1em 0.2em 0.2em #ddd; background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient([[:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); padding: 0.1em 0.4em; font-family: inherit; font-size: 1em; }
.h3 { color: #E65100; font-size: 12px; font-weight: bold; }
.code { font-family: monospace; font-size: 10pt; background: #eee; padding: 1pt 3pt; }

#tooltiptext {
  visibility: hidden;
  padding: 5px 10px;
  font-size: 75%;
  line-height:110%;
  text-align: center;
  background-color: black;
  color: #ddd;
  border-radius: 6px;
  position: fixed;
  bottom: 11px;
  right: 62px;
  z-index: 2;
}
#tooltiptext::after {
  content: " ";
  position: absolute;
  top: 50%;
  left: 100%;
  margin-top: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent transparent black;
}
.tooltip:hover #tooltiptext {
  visibility: visible;
}
#return-link {
    position: fixed;
    bottom: 10px;
    right: 10px;
    overflow: visible;
    font-size:120%;
    background: rgba(0, 0, 0, 0.75);
    border-style: solid;
    border-width: 3pt;
    border-color: #202020;
    border-radius: 4px;
    cursor: pointer;
    }
#return-link > p { padding:3px; margin:0; color:#C0C0C0;}
.MATLAB-Help {
width: 100%;
margin-bottom: 12px;
border: 1px solid #ccc;
border-right: none;
border-bottom: none;
font-size: 96%;
line-height: 1.4;
table-layout: fixed;
overflow:hidden;}

.MATLAB-Help > thead > tr > th {
padding: 6px 5px;
border: none;
border-right: 1px solid #ccc;
border-bottom: 1px solid #ccc;
background: #F2F2F2;
color: #000;
font-weight: bold;
text-align: left;
vertical-align: middle;}

.MATLAB-Help td{padding: 5px 5px;
border: none;
border-right: 1px solid #ccc;
border-bottom: 1px solid #ccc;
vertical-align: middle;}

.language-matlab { line-height:135% }

.collapse-link {float:right; line-height:200%; padding-left:10px; margin:0}


details > summary,
.details-div {
  padding: 8px 20px;
  border-style: solid;
  border-width: 1.2pt;
  border-color: #E0E0E0;
}
details > summary {
  border-radius:6px 6px 0 0;
  background-color: #F2F2F2;
  cursor: pointer;
}
.details-div {
  border-top-style: none;
  border-radius: 0 0 6px 6px;
}
.image-fit-svg,
.image-fit {
    max-width:  95%;
    max-height: 100%;
    margin:     auto;
}
.image-fit-svg{ padding:0px; max-width:500px; }
details > img.image-fit-svg{ padding: 0px 0px 10px; }
@media (max-width: 580px) {
  .image-fit-svg { max-width: 95%; }
}
.pretty-link  { color:#001188 !important; }
</style>
<style id="dark-theme">
    h2, h3       { color: #B0B0B0; }
    html body    { background-color: #101010; color: #B0B0B0; }
    .pretty-link { color: #C46313 !important; }
    a, a:visited, my-a  { color: #C46313 }
    a:hover, my-a:hover { color: orange; }
    details > summary,
    .details-div      { border-color:     #505050; }
    details > summary { background-color: #202020; }
    pre.codeinput     { border-width: 1.2pt; border-color:#001B33; background:#001129; color:#F0F0F0; }
    pre.codeoutput    { color:#A5A5A5; }
    span.keyword      { color:#FF9D00; }
    span.comment      { color:#808080; }
    span.string       { color:#3AD900; }
    span.untermstring { color:#FFEE80; }
    span.syscmd       { color:#CCCCCC; }
    .MATLAB-Help, .MATLAB-Help > thead > tr > th, .MATLAB-Help td { border-color:#505050; }
    .MATLAB-Help > thead > tr > th { background: #202020; color: #B0B0B0; }
    .summary-sub-heading { color:#909090; }
    .show-if-light    { display:none }
</style>
<style id="hide-dark">
     .show-if-dark { display:none }
</style>

<style id="anchor-offsets">
    h2::before, a[id]::before{
    content: "";
    display: block;
    height: 100px;
    margin: -100px 0 0;
    visibility: hidden;
    width:10%;
    z-index: -1;
}
</style>

<script>
          var returnElem = null;
          var skipCheck  = false;

          function hide_back_link()
          {
              returnButton.style.display = "none";
              try{
                 window.removeEventListener("scroll", update_back_position, true);
                 window.removeEventListener("resize", update_back_position, true);
                 parent.window.removeEventListener("scroll", update_back_position, true);
                 parent.window.removeEventListener("resize", update_back_position, true);}
              catch(e){}
          }

          function get_offset(element)
          {
              if (!element.getClientRects().length){ return { top: 0, left: 0 }; }
              var rect = element.getBoundingClientRect();
              var win  = element.ownerDocument.defaultView;
              return ( {top:  rect.top  + win.pageYOffset,
                        left: rect.left + win.pageXOffset} );
          }

          function jump_to()
          {
              var clickedElem = event.target;
              var clickedID   = clickedElem.closest("span");
              if (clickedID){
                clickedID = clickedID.getAttribute("id");
                if (clickedID.localeCompare("jump-close")===0) { return };}
              clickedID = clickedElem.closest("div").getAttribute("id");
              if (clickedID && clickedID.localeCompare("return-link")===0)
              {
                  if (returnElem)
                  {
                      event.preventDefault();
                      hide_back_link();
                      returnElem.scrollIntoView();
                      if (contentDiv.getAttribute("data-isHelpBrowser")){
                         contentDiv.scrollTop = contentDiv.scrollTop-100; }
                      if (contentDiv.getAttribute("data-isMATLABCentral")){
                         parent.window.scrollBy(0,-100)}
                      returnElem = null;
                  }
              }
              else
              {
                  var href = clickedElem.closest("my-a").getAttribute("href");
                  if ( href && href[0] == "#" )
                  {
                     var target = document.getElementById(href.substring(1));
                     var enclosingBox = target;
                     while ( enclosingBox )
                     {
                        prevBox      = enclosingBox;
                        enclosingBox = enclosingBox.closest("details");
                        if ( enclosingBox===prevBox ){
                           enclosingBox = enclosingBox.parentElement
                           if ( enclosingBox ) { enclosingBox = enclosingBox.closest("details"); }  }
                        if (enclosingBox && !enclosingBox.open) { open_details(enclosingBox.id) }
                     }
                     if (target){
                        event.preventDefault();
                        target.scrollIntoView(); }
                     var nextElem = target.nextElementSibling;
                     var nextNode = target.nextSibling;
                     while ( nextNode && nextNode.nodeType==Node.TEXT_NODE && nextNode.data.trim().length == 0 ){
                        nextNode = nextNode.nextSibling;}
                     if ( nextElem && nextElem===nextNode && nextElem.localName.localeCompare("details")===0 && !nextElem.open){
                        open_details(nextElem.id);}
                  }
                  else { return }
                  if (!contentDiv.getAttribute("data-isHelpBrowser"))
                  {
                      update_back_position();
                      returnButton.style.display = "block";
                      var linkTop   = clickedElem.offsetTop;
                      var targetTop = target.offsetTop;
                      if (targetTop>linkTop){
                          document.getElementById("down").style.display = "none";
                          document.getElementById("up").style.display   = "inline"; }
                      else{
                          document.getElementById("up").style.display   = "none";
                          document.getElementById("down").style.display = "inline"; }
                      returnElem = clickedElem;
                  }
              }
          }

          function open_details(detailsID)
          {
              var details  = document.getElementById(detailsID);
              skipCheck    = true;
              state_check(details.id);
              details.open = true;
          }

          function update_back_position()
          {
              try
              {
                  window.addEventListener("scroll", update_back_position, true);
                  window.addEventListener("resize", update_back_position, true);
                  var scrollPos;
                  if (in_iFrame())
                  {
                      parent.window.addEventListener("scroll", update_back_position, true);
                      parent.window.addEventListener("resize", update_back_position, true);
                      var iFrame         = window.frameElement;
                      var frameOffset    = get_offset(iFrame);
                      var documentBottom = parent.window.innerHeight  + parent.window.scrollY;
                      var extHeight      = Math.round(frameOffset.top + iFrame.getBoundingClientRect().height - documentBottom);
                      if (extHeight<0) { extHeight = 0; }
                      returnButton.style.bottom = (10+extHeight) + "px";
                      document.getElementById("tooltiptext").style.bottom = (11+extHeight) + "px";
                      scrollPos = contentDiv.scrollTop - 25 + iFrame.getBoundingClientRect().height - extHeight;
                  }
                  else{
                      scrollPos = window.scrollY + window.innerHeight - 25;}
                  if (returnElem.offsetTop>scrollPos){
                      document.getElementById("down").style.display = "inline";
                      document.getElementById("up").style.display   = "none";   }
                  else{
                      document.getElementById("down").style.display = "none";
                      document.getElementById("up").style.display   = "inline"; }
              }
              catch(e){}
          }
          function set_theme(themePref)
          {
            var themeSwitch     = document.getElementById("ToggleTheme");
            var themeSwitchText = "switch to";
            var switchToText    = null;
            if (!themePref){ themePref = get_theme_pref(); }
            if (themePref.localeCompare("light")===0){
                document.getElementById("dark-theme").sheet.disabled = true;
                document.getElementById("hide-dark").sheet.disabled  = false;
                switchToText = " dark theme";}
            else{
                document.getElementById("dark-theme").sheet.disabled = false;
                document.getElementById("hide-dark").sheet.disabled  = true;
                switchToText = " light theme";}
            themeSwitch.innerHTML = themeSwitchText + switchToText;
            set_theme_pref(themePref);
          }

          function toggle_theme()
          {
            if (document.getElementById("dark-theme").sheet.disabled) { set_theme("dark");  }
            else                                                      { set_theme("light"); }
          }

          function set_theme_pref(themePref)
          {
              var d = new Date();
              d.setTime(d.getTime() + (2*365*24*60*60*1000));
              var expires = "expires="+ d.toUTCString();
              document.cookie = "themepref=" + themePref + ";" + expires + "path=/";
              localStorage.setItem("PRETTY_THEME", themePref);
          }

          function get_theme_pref() {
              var name = "themepref=";
              var decodedCookie = decodeURIComponent(document.cookie);
              var ca = decodedCookie.split(';');
              for(var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                  c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                  return c.substring(name.length, c.length);
                }
              }
              var docTheme = localStorage.getItem("PRETTY_THEME");
              if (docTheme) { return docTheme }
              else          { return "light"  }
          }

          function toggle_details(section)
          {
            var link;
            var subSection;
            var details;
            var linkText;
            var i;
            var openState  = true;
            var border     = "6px 6px 0 0;"
            if (section===0)
            {
              link = document.getElementById("Toggle"+section.toString());
              if (link.innerHTML.localeCompare("collapse all on page")===0){
                  openState = false;
                  border    = "6px;"
                  linkText  = "expand all";}
              else{
                  linkText   = "collapse all";}
              link.innerHTML = linkText + " on page";
              for (i = 0; i < allDetails.length; i++){
                 allDetails[i].open = openState;
                 allDetails[i].children[0].setAttribute( 'style', "border-radius:"+border );
                 link = document.getElementById("Toggle"+allDetails[i].id.split(".", 1));
                 if (allDetails[i].id.charAt(0).localeCompare("0") && link){link.innerHTML = linkText;}}
            }
            else
            {
               link = document.getElementById("Toggle"+section.toString());
               subSection = 1;
               if (link.innerHTML.localeCompare("collapse all")===0){
                  openState      = false;
                  border         = "6px;"
                  link.innerHTML = "expand all";}
               else{
                  link.innerHTML = "collapse all";}
               details = document.getElementById(section.toString()+"."+subSection.toString());
               while (details){
                    details.open = openState;
                    details.children[0].setAttribute( 'style', "border-radius:"+border );
                    subSection++;
                    details = document.getElementById(section.toString()+"."+subSection.toString());}
               var allCollapsed = true;
               var allExpanded  = true;
               for (i = 0; i < allDetails.length; i++){
                   check_if_open(allDetails[i]);}
               link = document.getElementById("Toggle0");
               if (allExpanded) {link.innerHTML = "collapse all on page";}
               if (allCollapsed){link.innerHTML = "expand all on page";}
            }
            function check_if_open(details)
            {
                if (details.open){allCollapsed = false;}
                else             {allExpanded  = false;}
            }
          }

          function state_check(detailsID)
          {
              // first deal with just the section
              if (event.detail){document.activeElement.blur();}
              var clickedElem   = event.target;
              if (!skipCheck && clickedElem.localName.localeCompare("summary"))
              { 
                if (!(clickedElem.closest("summary"))) { return };
              };
              var details       = document.getElementById(detailsID);
              if ( !skipCheck ) {
                  var parentID  = clickedElem.closest("details").id;
                  if (details.id.localeCompare(parentID)) { return };}
              skipCheck         = false;
              var clickedStatus = details.open;
              var section       = detailsID.split(".", 1);
              var subSection    = 1;
              var allCollapsed  = true;
              var allExpanded   = true;
              var link          = document.getElementById("Toggle"+section);
              if (clickedStatus) { details.children[0].setAttribute( 'style', "border-radius:6px;" ); }
              else               { details.children[0].setAttribute( 'style', "border-radius:6px 6px 0 0;" ); }
              if (link)
              {
                  details = document.getElementById(section+"."+subSection.toString());
                  while (details){
                    check_if_open(details);
                    subSection++;
                    details = document.getElementById(section+"."+subSection.toString());}
                  if (allExpanded) {link.innerHTML = "collapse all";}
                  if (allCollapsed){link.innerHTML = "expand all";}
              }
              // then the whole page
              allCollapsed   = true;
              allExpanded    = true;
              for (var i = 0; i < allDetails.length; i++){
                  check_if_open(allDetails[i]);}
              link = document.getElementById("Toggle0");
              if (allExpanded) {link.innerHTML = "collapse all on page";}
              if (allCollapsed){link.innerHTML = "expand all on page";}

              function check_if_open(details)
              {
                  var openStatus
                  if (detailsID.localeCompare( details.id )===0 ){openStatus = !clickedStatus;}
                  else                                           {openStatus = details.open;}
                  if (openStatus){allCollapsed = false;}
                  else           {allExpanded  = false;}
              }
          }

          function in_iFrame ()
          {
               try {
                   return window.self !== window.top;
               } catch (e) {
                   return true;
               }
          }
</script>

</head>
<body>
<div class="content">
<div id="return-link" style="display:none;" class="tooltip">
<p onclick="jump_to()">
    <span onclick="jump_to()"><span id="up">&#8679;</span><span id="down">&#8681;</span>
    <span onclick="hide_back_link()" style="padding:2px; font-size:120%;" id="jump-close"><b onclick="hide_back_link()">&times;</b></span></span>
</p>
<div id="tooltiptext">click to return
<br>(click <b>&times;</b> to hide)</div>
</div><script>document.getElementById("dark-theme").sheet.disabled = true;</script>
<h1>Alignment and Drift Correction</h1>
<!--introduction-->
<p>The Alignment and Drift Correction tool can be used either to align slice of the opened dataset or to align two separate datasets.</p>
<p>
<b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <code><b>--&gt;</b></code> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu.html"><b>Menu</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu_dataset.html"><b>Dataset</b></a>
</p>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<my-a onclick="jump_to()" href="#1">Demos and tutorials</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#2">Current dataset panel</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#3">Align panel</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#4">Options panel</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#5">Second stack panel</my-a>
</li>
<li>
<my-a onclick="jump_to()" href="#6">Reference and Acknowledgements</my-a>
</li>
</ul>
</div>
<h2 id="1">Demos and tutorials</h2>
<p>
A demonstration is available in the following videos:
<br>
<a href="https://youtu.be/-qwoO5z02aA"><img class="image-fit" style="vertical-align:middle;" src="images\youtube.png"> How to do image alignment</a>
<br>
<a href="https://youtu.be/rlXoyZcTpJs"><img class="image-fit" style="vertical-align:middle;" src="images\youtube.png"> Multi-point landmarks,  https://youtu.be/rlXoyZcTpJs</a>
<br>
<a href="https://youtu.be/-en5zD5Ou9s"><img class="image-fit" style="vertical-align:middle;" src="images\youtube.png"> Automatic feature-based</a>
<br>
<a href="https://youtu.be/tpe9GhpS2o8"><img class="image-fit" style="vertical-align:middle;" src="images\youtube.png"> Automatic feature-based using HDD mode</a>
<br>
<a href="https://youtu.be/FtvWjDUMZ1I"><img class="image-fit" style="vertical-align:middle;" src="images\youtube.png"> HDD mode</a> (Drift correction and Automatic feature based only)
<br>
</p>
<p><span style="line-height:8px; display:block; vertical-align:top">
<br></span></p>
<h2 id="2">Current dataset panel</h2>
<p>The <b>Current dataset panel</b> displays details of the currently opened dataset, such as its filename, dimensions and pixel size</p>
<p>
<img class="image-fit" src="images/menuDatasetAlignTool_1.jpg" alt=""> </p>
<h2 id="3">Align panel</h2>
<p>The <b>Align panel</b> allows to select main parameters for the alignment and drift correction.</p>
<p>
<img class="image-fit" src="images/menuDatasetAlignTool_2.jpg" alt=""> </p>

<ul>
  <li>
    <b>The Mode panel</b> - selection of alignment mode:
      <ul>
          <li><b>Current dataset</b>, align the opened dataset</li>
          <li><b>Two stacks</b>, align two stacks. The second stack can either be loaded or imported from MATLAB</li>
      </ul>
  </li>
  <li>
    <b>Algorithm</b> - selection of method to be used for the alignment:
    <table style="width: 950px; text-align: center; margin-left: 50px;" cellspacing=2px cellpadding=2px >
    <tr>
      <td style="width=250px;"><b>Drift correction</b></td>
      <td>The Drift correction mode is recommended for small shifts or comparably sized images
<br>
          It is recommended for most situations and also implemented for
          image files without loading them into MIB (see the <b>HDD
          mode</b> below. <em>The image size should be the same in all
          files!</em>
      </td>
    </tr>
    <tr>
      <td><b>Template matching</b></td>
      <td>The Template matching mode is best when aligning two stacks and the second stack is smaller than the main stack.
<br>
          It is <b>not</b> recommended for alignment of the currently opened stack
      </td>
      </td>
    </tr>
    <tr>
      <td><b>Automatic feature-based</b></td>
      <td><a href="https://www.youtube.com/embed/-en5zD5Ou9s"><img class="image-fit" src="images/youtube.png"> Standard mode, </a>
      <a href="https://youtu.be/tpe9GhpS2o8"><img class="image-fit" src="images/youtube.png"> HDD mode</a>
      
<br>The automatic image alignement based on features (blobs,
      regions or corners) detected on consecutive slices.
<br>
      The available
      transfomations are 'similarity', 'affine', or 'projective' (see
      below for details). The resulting datasets can be cropped to the
      size and around the position of the first image (the cropped mode)
      or extended.
<br>
      Use the Preview button to check the number and
      positions of the detected points.
<br>
      Please refer to the documentation of the <a href="https://se.mathworks.com/help/vision/ref/matchfeatures.html">matchFeatures</a> function of
      MATLAB for more details.
      
<br>
<br>
      This mode is also implemented for image files without loading them into MIB (see the <b>HDD mode</b> below.
      
<br>
<br>
      Here some short description of features, adapted from this <a
      href="https://stackoverflow.com/questions/49963061/what-is-the-best-feature-detection">topic</a>
<br>
      <ul>
      <li><b>SURF</b> is often considered to be the best feature
      detectors out there, for good reasons, it is very robust and very
      fast in most situations; may not work with with highly detailed
      targets (electrical boards for instance)</li>
      <li><b>FAST</b> is, as its name suggests, very fast, and very "greedy", it extracts a lot of keypoints compared to other detectors,
       but it is not rotation invariant (meaning that it won't work if
       the target is rotated respect the reference image)</li>
      <li><b>BRIEF</b> has good performance and does extract a lower
      number of keypoints than FAST, just like FAST it is not rotation
      invariant</li>
      <li><b>ORB</b> is basically an evolution of the previous 2 detectors (ORB stands for Oriented fast and Rotated Brief) that is rotation invariant
      and also implements its own descriptor, this is probably the best choice for general purposes; its robustness is comparable to SURF while
      the performances slightly overcomes it (using default parameters), altrough the robustnes is actually a little inferior in most of the situations,
      there are specific scenarios in which it overcomes SURF (once again
      electrical boards for instance)</li>
      <li><b>BRISK</b> has a behavior very similar to ORB with a little more CPU load, since ORB in most cases works better in both terms of robustness
      and performances people usually end up using ORB instead</li>
      </td>
    </tr>
    <tr>
      <td><b>AMST: Alignment to Median Smoothed Template</b></td>
      <td>This alignement can be used to compensate for slight local
      deformations of 3D electron microscopy datasets.
<br>
      The dataset has to be prealigned using the Drift correction mode, after that it is registered against its own median smoothed in Z copy.
      
<br>
<br>The algorithm is based on paper by <a href="https://www.nature.com/articles/s41598-020-58736-7">Hennies J, Lleti JMS,
      Schieber NL, Templin RM, Steyer AM, Schwab Y. AMST: Alignment to
      Median Smoothed Template for Focused Ion Beam Scanning Electron
      Microscopy Image Stacks, <em>Sci Rep. 2020 Feb 6;10(1):2004. doi:
      10.1038/s41598-020-58736-7</em></a>
<br>
<br>
      <ul>
      <li>Use the <em>Median size</em> editbox to specify number of Z-section
      to be used for median smoothing</li>
      <li>Press the <em>Settings</em> button to set the parameters, refer to
      MATLAB documentation for <a
      href="https://se.mathworks.com/help/images/ref/imregtform.html">imregtform
      function</a> for details</li>
      </ul>
<br>
      A demonstration is available in the following video:
<br>
      <a href="https://youtu.be/MNt_Yzt4pw0"><img class="image-fit" style="vertical-align:middle;" src="images\youtube.png">  https://youtu.be/MNt_Yzt4pw0</a>
      </td>
    </tr>
    <tr>
      <td><b>Single landmark point</b></td>
      <td>The Single landmark point mode is a manual mode, where user marks
      corresponding areas on two consequetive slices using the brush tool with
      a spot. During alignment the images will be translated to align the
      marked areas
      </td>
    </tr>
    <tr>
      <td><b>Landmarks, multi points</b></td>
      <td>Landmarks, multi points align datasets based on marked points.
      The points for alignment can be selected using the Selection layer or Annotations
      (<em>recommended</em>), where the corresponding points should have
      the same name. A table below indicates various transformation
      types:
<br>
      <img class="image-fit" src="images/menuDatasetAlignToolLandmarkModes.jpg">
      </td>
    </tr>
    <tr>
      <td><b>Three landmark points</b></td>
      <td><b>It is recommended to use the <em>Landmarks, multi points mode</em> instead!</b>
<br>
          Three landmark points mode is another manual mode, where user should mark
          three corresponding areas on two consequetive slices using the brush tool.
          During alignment the images will be translated/scaled/rotated to
          align the marked areas
      </td>
      <tr>
      <td><b>Color channels, multi points</b></td>
      <td>Use landmarks, to register individual color channels. The
      landmarks are defined using MIB annotations (<em>Segmentation
      panel->Annotations</em>) as 
<br>
      <b>a)</b> the annotation text is used to identify the corresponding points
      (i.e. two corresponding points should have the same annotation
      text);
<br>
      <b>b)</b> the annotation value is used to identify the fixed color
      channel (as number 1) and the color channel that needs to be
      transformed (as number 2)
<br>
<br>
      <img class="image-fit" src="images/Alignment_Colorchannels.jpg">
      </td>
    </tr>
    </tr>
    </table>
  </li>
  <li>
      <b>HDD mode</b> -
      <a href="https://youtu.be/FtvWjDUMZ1I"><img class="image-fit" src="images/youtube.png"> Drift correction</a>,
      <a href="https://youtu.be/tpe9GhpS2o8"><img class="image-fit" src="images/youtube.png"> Feature-based</a>,
      when selected the alignment tool will align
      files specified in the bottom panel of the window
      (<em>HDD Mode (Image directories and formats)</em>). This mode is
      suitable for large collection of images that can not be fit into
      computer memory. This mode is only implemented for the "Drift
      correction" (<b>the images should be of the same size</b>) and "Automatic feature-based" algorithms
<br>
  </li>
  <li>
    <b>Correlate with</b> - three different options for the reference slide:
      <ul>
          <li><b>Previous slice</b>, align each slice to the previous one</li>
          <li><b>First slice</b>, align all images to the first Z-slice of the sequence; it is good from fixing drift correction problems, when dataset is not changing much</li>
          <li><b>Relative to</b>, align each slice to another slice with is earlier in the sequence, the number in the <b>Step</b> edit box defines this shift</li>
      </ul>
  </li>
  <li>
    <b>Color channel</b> - selection of the color channel to use for the alignment process
  </li>
  <li>
    <b>use intensity gradient</b> sometimes better alignement can be
    achieved when correlating intensity gradients of the original images.
    Select this checkbox to use the gradients instad of raw images.
  </li>
  <li>
    <b>Background</b> define type of the background after image alignment
      <ul>
          <li><b>White</b>, all background pixels of the aligned dataset will be white</li>
          <li><b>Black</b>, all background pixels of the aligned dataset will be black</li>
          <li><b>Mean</b>, all background pixels of the aligned dataset will be calculated as an average value of all pixels of the original dataset</li>
          <li><b>Custom</b>, provide a custom intensity for the background colors</li>
      </ul>
  </li>
</ul>

<h2 id="4">Options panel</h2>
<p>The Options panel is shown only during alignment of the currently opened dataset.</p>
<p>
<img class="image-fit" src="images/menuDatasetAlignTool_3.jpg" alt=""> </p>

<ul>
  <li>
    <b>use Mask/Selection</b> check this to force the alignment tool to
    calculate correlation only from the masked or selected areas of the
    dataset. To benefit from this mode use the brush tool to select the
    most distict area on the first and last slices; after that
    interpolate one area to another using the I-key shortcut (or from the
    <em>Menu->Selection->Interpolate as Shape</em>)
  </li>
  <li>
    <b>use subwindow</b> for large uniform images use of subwindow can
    speed up the alignment significantly. Use the <em>minX, minY, maxX,
    maxY</em> edit boxes or the <em>Get from Selection</em> button to
    define the subwindow.
  </li>
  <li>
    <b>Save/Load shifts to file</b> using this option it is possible to
    save and load the translation shifts to a disk
  </li>
  <li>
  <ul><b>HDD Mode (image directories and formats) panel</b>
<br>
      this panel is used only when the <em>HDD Mode</em> is enabled.
      <li><b>Extension</b> - extension of files that should be
      aligned</li>
      <li><span class="kbd">[&#10003;] <b>Bio</b></span> - enable the Bio-Formats file reader to load images
      in various microscope formats</li>
      <li><b>Index</b> - a numeric index of a series to load from a
      container of images [Bio-formats only]</li>
      <li><b>...</b> - press to select directory with images to
      process</li>
      <li><b>Output subfolder and extension</b> - specify output
      subfolder (relative to the input folder) to save aligned images and
      set the output file format.</li>
      </ul>
  </li>
</ul>

<h2 id="5">Second stack panel</h2>
<p>The Options panel is shown only during alignment of two stacks</p>
<p>
<img class="image-fit" src="images/menuDatasetAlignTool_4.jpg" alt=""> </p>

<ul>
  <li>
    <b>Directory of images</b> select directory where images of the
    second stack are located
  </li>
  <li>
    <b>Volume in a single file</b>, use this option when the second stack
    is embedded into a single file
  </li>
  <li>
    <b>Import from MATLAB</b>, if another stack is already open in MATLAB
    it can be imported and aligned with the currently open.
  </li>
  <li>
    <b>Automatic mode</b>, when selected the aligment is done
    automatically. Alternatively, it is possible to provide parameters
    manually into the <em>ShiftX</em> and <em>ShiftY</em> edit boxes.
  </li>
</ul>

<h2 id="6">Reference and Acknowledgements</h2>
<p>The alignment algorithm is based on</p>

<ul>
<li> JC Russ, The image processing handbook, CRC Press, Boca Raton, FL, 1994</li>
<li> JD Sugar, AW Cummings, BW Jacobs, DB Robinson, A Free MATLAB Script
For Spatial Drift Correction, Microscopy Today, Volume 22, Number 5,
2014
<br>
<a href="https://se.mathworks.com/matlabcentral/fileexchange/45453-drifty-shifty-deluxe-m">https://se.mathworks.com/matlabcentral/fileexchange/45453-drifty-shifty-deluxe-m</a></li>
</ul>

<p>
<b>Back to</b> <a href="im_browser_product_page.html"><b>Index</b></a> <code><b>--&gt;</b></code> <a href="im_browser_user_guide.html"><b>User Guide</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu.html"><b>Menu</b></a> <code><b>--&gt;</b></code> <a href="ug_gui_menu_dataset.html"><b>Dataset</b></a>
</p>
<p></p>
<p>
<script>
  var allDetails = document.getElementsByTagName('details');
  toggle_details(0);
</script>
</p>
<p class="footer">

<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a> and subsequently processed by <a class="pretty-link" href="https://www.mathworks.com/matlabcentral/fileexchange/78059-prettify-matlab-html">prettify_MATLAB_html</a> V6.8b2</p>
<p id="iFrameBuf">&nbsp;</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Alignment and Drift Correction
% The Alignment and Drift Correction tool can be used either to align slice of the opened dataset or to align two
% separate datasets. 
% 
%
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu.html *Menu*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu_dataset.html *Dataset*>
%
%% Demos and tutorials
%
% <html lang="en">
% A demonstration is available in the following videos:
<br>
% <a href="https://youtu.be/-qwoO5z02aA"><img style="vertical-align:middle;" src="images\youtube.png"> How to do image alignment</a>
<br>
% <a href="https://youtu.be/rlXoyZcTpJs"><img style="vertical-align:middle;" src="images\youtube.png"> Multi-point landmarks,  https://youtu.be/rlXoyZcTpJs</a>
<br>
% <a href="https://youtu.be/-en5zD5Ou9s"><img style="vertical-align:middle;" src="images\youtube.png"> Automatic feature-based</a>
<br>
% <a href="https://youtu.be/tpe9GhpS2o8"><img style="vertical-align:middle;" src="images\youtube.png"> Automatic feature-based using HDD mode</a>
<br>
% <a href="https://youtu.be/FtvWjDUMZ1I"><img style="vertical-align:middle;" src="images\youtube.png"> HDD mode</a> (Drift correction and Automatic feature based only)
<br>
% </html>
%
% [br8]
%
%% Current dataset panel
% 
% The *Current dataset panel* displays details of the currently opened
% dataset, such as its filename, dimensions and pixel size
% 
% <<images/menuDatasetAlignTool_1.jpg>>
% 
%
%% Align panel
% The *Align panel* allows to select main parameters for the alignment and
% drift correction.
% 
% <<images/menuDatasetAlignTool_2.jpg>>
%
%
% <html lang="en">
% <ul>
%   <li>
%     <b>The Mode panel</b> - selection of alignment mode:
%       <ul>
%           <li><b>Current dataset</b>, align the opened dataset</li>
%           <li><b>Two stacks</b>, align two stacks. The second stack can either be loaded or imported from MATLAB</li>
%       </ul>
%   </li>
%   <li>
%     <b>Algorithm</b> - selection of method to be used for the alignment:
%     <table style="width: 950px; text-align: center; margin-left: 50px;" cellspacing=2px cellpadding=2px >
%     <tr>
%       <td style="width=250px;"><b>Drift correction</b></td>
%       <td>The Drift correction mode is recommended for small shifts or comparably sized images
<br>
%           It is recommended for most situations and also implemented for
%           image files without loading them into MIB (see the <b>HDD
%           mode</b> below. <em>The image size should be the same in all
%           files!</em>
%       </td>
%     </tr>
%     <tr>
%       <td><b>Template matching</b></td>
%       <td>The Template matching mode is best when aligning two stacks and the second stack is smaller than the main stack.
<br>
%           It is <b>not</b> recommended for alignment of the currently opened stack
%       </td>
%       </td>
%     </tr>
%     <tr>
%       <td><b>Automatic feature-based</b></td>
%       <td><a href="https://www.youtube.com/embed/-en5zD5Ou9s"><img src="images/youtube.png"> Standard mode, </a> 
%       <a href="https://youtu.be/tpe9GhpS2o8"><img src="images/youtube.png"> HDD mode</a>
%       
<br>The automatic image alignement based on features (blobs,
%       regions or corners) detected on consecutive slices.
<br>
%       The available
%       transfomations are 'similarity', 'affine', or 'projective' (see
%       below for details). The resulting datasets can be cropped to the
%       size and around the position of the first image (the cropped mode)
%       or extended.
<br>
%       Use the Preview button to check the number and
%       positions of the detected points.
<br>
%       Please refer to the documentation of the <a href="https://se.mathworks.com/help/vision/ref/matchfeatures.html">matchFeatures</a> function of
%       MATLAB for more details.
%       
<br>
<br>
%       This mode is also implemented for image files without loading them into MIB (see the <b>HDD mode</b> below. 
%       
<br>
<br>
%       Here some short description of features, adapted from this <a
%       href="https://stackoverflow.com/questions/49963061/what-is-the-best-feature-detection">topic</a>
<br>
%       <ul>
%       <li><b>SURF</b> is often considered to be the best feature
%       detectors out there, for good reasons, it is very robust and very
%       fast in most situations; may not work with with highly detailed
%       targets (electrical boards for instance)</li>
%       <li><b>FAST</b> is, as its name suggests, very fast, and very "greedy", it extracts a lot of keypoints compared to other detectors,
%        but it is not rotation invariant (meaning that it won't work if
%        the target is rotated respect the reference image)</li>
%       <li><b>BRIEF</b> has good performance and does extract a lower
%       number of keypoints than FAST, just like FAST it is not rotation
%       invariant</li>
%       <li><b>ORB</b> is basically an evolution of the previous 2 detectors (ORB stands for Oriented fast and Rotated Brief) that is rotation invariant 
%       and also implements its own descriptor, this is probably the best choice for general purposes; its robustness is comparable to SURF while 
%       the performances slightly overcomes it (using default parameters), altrough the robustnes is actually a little inferior in most of the situations, 
%       there are specific scenarios in which it overcomes SURF (once again
%       electrical boards for instance)</li>
%       <li><b>BRISK</b> has a behavior very similar to ORB with a little more CPU load, since ORB in most cases works better in both terms of robustness
%       and performances people usually end up using ORB instead</li>
%       </td>
%     </tr>     
%     <tr>
%       <td><b>AMST: Alignment to Median Smoothed Template</b></td>
%       <td>This alignement can be used to compensate for slight local
%       deformations of 3D electron microscopy datasets.
<br>
%       The dataset has to be prealigned using the Drift correction mode, after that it is registered against its own median smoothed in Z copy.
%       
<br>
<br>The algorithm is based on paper by <a href="https://www.nature.com/articles/s41598-020-58736-7">Hennies J, Lleti JMS, 
%       Schieber NL, Templin RM, Steyer AM, Schwab Y. AMST: Alignment to
%       Median Smoothed Template for Focused Ion Beam Scanning Electron
%       Microscopy Image Stacks, <em>Sci Rep. 2020 Feb 6;10(1):2004. doi:
%       10.1038/s41598-020-58736-7</em></a>
<br>
<br>
%       <ul>
%       <li>Use the <em>Median size</em> editbox to specify number of Z-section
%       to be used for median smoothing</li>
%       <li>Press the <em>Settings</em> button to set the parameters, refer to
%       MATLAB documentation for <a
%       href="https://se.mathworks.com/help/images/ref/imregtform.html">imregtform
%       function</a> for details</li>
%       </ul>
<br>
%       A demonstration is available in the following video:
<br>
%       <a href="https://youtu.be/MNt_Yzt4pw0"><img style="vertical-align:middle;" src="images\youtube.png">  https://youtu.be/MNt_Yzt4pw0</a>
%       </td>
%     </tr>
%     <tr>
%       <td><b>Single landmark point</b></td>
%       <td>The Single landmark point mode is a manual mode, where user marks
%       corresponding areas on two consequetive slices using the brush tool with
%       a spot. During alignment the images will be translated to align the
%       marked areas
%       </td>
%     </tr>
%     <tr>
%       <td><b>Landmarks, multi points</b></td>
%       <td>Landmarks, multi points align datasets based on marked points.
%       The points for alignment can be selected using the Selection layer or Annotations
%       (<em>recommended</em>), where the corresponding points should have
%       the same name. A table below indicates various transformation
%       types:
<br>
%       <img src="images/menuDatasetAlignToolLandmarkModes.jpg">
%       </td>
%     </tr>
%     <tr>
%       <td><b>Three landmark points</b></td>
%       <td><b>It is recommended to use the <em>Landmarks, multi points mode</em> instead!</b>
<br>
%           Three landmark points mode is another manual mode, where user should mark
%           three corresponding areas on two consequetive slices using the brush tool. 
%           During alignment the images will be translated/scaled/rotated to
%           align the marked areas 
%       </td>
%       <tr>
%       <td><b>Color channels, multi points</b></td>
%       <td>Use landmarks, to register individual color channels. The
%       landmarks are defined using MIB annotations (<em>Segmentation
%       panel->Annotations</em>) as 
<br>
%       <b>a)</b> the annotation text is used to identify the corresponding points
%       (i.e. two corresponding points should have the same annotation
%       text);
<br>
%       <b>b)</b> the annotation value is used to identify the fixed color
%       channel (as number 1) and the color channel that needs to be
%       transformed (as number 2)
<br>
<br>
%       <img src="images/Alignment_Colorchannels.jpg">
%       </td>
%     </tr>
%     </tr>
%     </table>
%   </li>
%   <li>
%       <b>HDD mode</b> - 
%       <a href="https://youtu.be/FtvWjDUMZ1I"><img src="images/youtube.png"> Drift correction</a>, 
%       <a href="https://youtu.be/tpe9GhpS2o8"><img src="images/youtube.png"> Feature-based</a>, 
%       when selected the alignment tool will align 
%       files specified in the bottom panel of the window 
%       (<em>HDD Mode (Image directories and formats)</em>). This mode is
%       suitable for large collection of images that can not be fit into
%       computer memory. This mode is only implemented for the "Drift
%       correction" (<b>the images should be of the same size</b>) and "Automatic feature-based" algorithms
<br>
%   </li>
%   <li>
%     <b>Correlate with</b> - three different options for the reference slide:
%       <ul>
%           <li><b>Previous slice</b>, align each slice to the previous one</li>
%           <li><b>First slice</b>, align all images to the first Z-slice of the sequence; it is good from fixing drift correction problems, when dataset is not changing much</li>
%           <li><b>Relative to</b>, align each slice to another slice with is earlier in the sequence, the number in the <b>Step</b> edit box defines this shift</li>
%       </ul>
%   </li>
%   <li>
%     <b>Color channel</b> - selection of the color channel to use for the alignment process
%   </li>
%   <li>
%     <b>use intensity gradient</b> sometimes better alignement can be
%     achieved when correlating intensity gradients of the original images.
%     Select this checkbox to use the gradients instad of raw images.
%   </li>
%   <li>
%     <b>Background</b> define type of the background after image alignment
%       <ul>
%           <li><b>White</b>, all background pixels of the aligned dataset will be white</li>
%           <li><b>Black</b>, all background pixels of the aligned dataset will be black</li>
%           <li><b>Mean</b>, all background pixels of the aligned dataset will be calculated as an average value of all pixels of the original dataset</li>
%           <li><b>Custom</b>, provide a custom intensity for the background colors</li>
%       </ul>
%   </li>
% </ul>
% </html>
%
%
%% Options panel
% The Options panel is shown only during alignment of the currently
% opened dataset.
%
% 
% <<images/menuDatasetAlignTool_3.jpg>>
%
%
% <html lang="en">
% <ul>
%   <li>
%     <b>use Mask/Selection</b> check this to force the alignment tool to
%     calculate correlation only from the masked or selected areas of the
%     dataset. To benefit from this mode use the brush tool to select the
%     most distict area on the first and last slices; after that
%     interpolate one area to another using the I-key shortcut (or from the
%     <em>Menu->Selection->Interpolate as Shape</em>)
%   </li>
%   <li>
%     <b>use subwindow</b> for large uniform images use of subwindow can
%     speed up the alignment significantly. Use the <em>minX, minY, maxX,
%     maxY</em> edit boxes or the <em>Get from Selection</em> button to
%     define the subwindow. 
%   </li>
%   <li>
%     <b>Save/Load shifts to file</b> using this option it is possible to
%     save and load the translation shifts to a disk
%   </li>
%   <li>
%   <ul><b>HDD Mode (image directories and formats) panel</b>
<br>
%       this panel is used only when the <em>HDD Mode</em> is enabled.
%       <li><b>Extension</b> - extension of files that should be
%       aligned</li>
%       <li><span class="kbd">[&#10003;] <b>Bio</b></span> - enable the Bio-Formats file reader to load images
%       in various microscope formats</li>
%       <li><b>Index</b> - a numeric index of a series to load from a
%       container of images [Bio-formats only]</li>
%       <li><b>...</b> - press to select directory with images to
%       process</li>
%       <li><b>Output subfolder and extension</b> - specify output
%       subfolder (relative to the input folder) to save aligned images and
%       set the output file format.</li>
%       </ul>
%   </li>
% </ul>
% </html>
%
%
%% Second stack panel
% The Options panel is shown only during alignment of two stacks
% 
% <<images/menuDatasetAlignTool_4.jpg>>
%
%
% <html lang="en">
% <ul>
%   <li>
%     <b>Directory of images</b> select directory where images of the
%     second stack are located
%   </li>
%   <li>
%     <b>Volume in a single file</b>, use this option when the second stack
%     is embedded into a single file
%   </li>
%   <li>
%     <b>Import from MATLAB</b>, if another stack is already open in MATLAB
%     it can be imported and aligned with the currently open.
%   </li>
%   <li>
%     <b>Automatic mode</b>, when selected the aligment is done
%     automatically. Alternatively, it is possible to provide parameters
%     manually into the <em>ShiftX</em> and <em>ShiftY</em> edit boxes.
%   </li>
% </ul>
% </html>
%
%% Reference and Acknowledgements
% The alignment algorithm is based on 
% 
% <html lang="en">
% <ul>
% <li> JC Russ, The image processing handbook, CRC Press, Boca Raton, FL, 1994</li>
% <li> JD Sugar, AW Cummings, BW Jacobs, DB Robinson, A Free MATLAB Script
% For Spatial Drift Correction, Microscopy Today, Volume 22, Number 5,
% 2014
<br>
% <a href="https://se.mathworks.com/matlabcentral/fileexchange/45453-drifty-shifty-deluxe-m">https://se.mathworks.com/matlabcentral/fileexchange/45453-drifty-shifty-deluxe-m</a></li>
% </ul>
% </html>
%
%
% *Back to* <im_browser_product_page.html *Index*> |*REPLACE_WITH_DASH_DASH>*| <im_browser_user_guide.html *User Guide*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu.html *Menu*> |*REPLACE_WITH_DASH_DASH>*| <ug_gui_menu_dataset.html *Dataset*>
%
%
% [cssClasses]
% .kbd { 
%   font-family: monospace;
% 	border: 1px solid #aaa; 
% 	-moz-border-radius: 0.2em; 
% 	-webkit-border-radius: 0.2em; 
% 	border-radius: 0.2em; 
% 	-moz-box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	-webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	box-shadow: 0.1em 0.2em 0.2em #ddd; 
% 	background-color: #f9f9f9; 
% 	background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); 
% 	background-image: linear-gradient(&#91;&#91;:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); 
% 	padding: 0.1em 0.4em; 
% 	font-family: inherit; 
% 	font-size: 1em;
% }
% .h3 {
% color: #E65100;
% font-size: 12px;
% font-weight: bold;
% }
% .code {
% font-family: monospace;
% font-size: 10pt;
% background: #eee;
% padding: 1pt 3pt;
% }
% [/cssClasses]
%%
% <html lang="en">
% <script>
%   var allDetails = document.getElementsByTagName('details');
%   toggle_details(0);
% </script>
% </html>
##### SOURCE END #####
-->
<script>
var allDetails   = document.getElementsByTagName('details');
var contentDiv   = document.getElementsByClassName("content"); contentDiv = contentDiv[0];
var returnButton = document.getElementById("return-link");
document.getElementById("iFrameBuf").style.display = "none";
if(in_iFrame())
{
   try{
      var footerNav = parent.document.getElementsByClassName("footernav");
      var tabPane   = parent.document.getElementsByClassName("tab-pane");}
   catch(err) { var footerNav = []; var tabPane = [];};
   if(!(footerNav.length) || tabPane.length)
   {
      contentDiv.style.overflowY = "scroll";
      contentDiv.style.overflowX = "hidden";
      contentDiv.style.position  = "absolute";
      contentDiv.style.width     = "95%";
      contentDiv.style.top       = 0;
      contentDiv.style.bottom    = 0;
      if (tabPane.length){
         contentDiv.setAttribute("data-isMATLABCentral","1");
         returnButton.style.right = "40px";
         document.getElementById("tooltiptext").style.right = "92px"; }
      document.getElementById("iFrameBuf").style.display = "block";
   }
   else { contentDiv.setAttribute("data-isHelpBrowser","1"); }
}
if (!contentDiv.getAttribute("data-isHelpBrowser") && !contentDiv.getAttribute("data-isMATLABCentral") ){
   document.getElementById("anchor-offsets").sheet.disabled = true; }
</script></body>
</html>
